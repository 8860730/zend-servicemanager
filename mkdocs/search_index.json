{
    "docs": [
        {
            "location": "/",
            "text": "zend-servicemanager\n\n\nMaster:\n\n\n\n\nDevelop:\n\n\n\n\n\nThe Service Locator design pattern is implemented by the \nZend\\ServiceManager\n\ncomponent. The Service Locator is a service/object locator, tasked with\nretrieving other objects.\n\n\n\n\nFile issues at https://github.com/zendframework/zend-servicemanager/issues\n\n\nOnline documentation\n\n\nDocumentation source files\n\n\n\n\nBenchmarks\n\n\nWe provide scripts for benchmarking zend-servicemanager using the\n\nPHPBench\n framework; these can be\nfound in the \nbenchmarks/\n directory.\n\n\nTo execute the benchmarks you can run the following command:\n\n\n$ vendor/bin/phpbench run --report=aggregate",
            "title": "Home"
        },
        {
            "location": "/#zend-servicemanager",
            "text": "Master:  \nDevelop:   The Service Locator design pattern is implemented by the  Zend\\ServiceManager \ncomponent. The Service Locator is a service/object locator, tasked with\nretrieving other objects.   File issues at https://github.com/zendframework/zend-servicemanager/issues  Online documentation  Documentation source files",
            "title": "zend-servicemanager"
        },
        {
            "location": "/#benchmarks",
            "text": "We provide scripts for benchmarking zend-servicemanager using the PHPBench  framework; these can be\nfound in the  benchmarks/  directory.  To execute the benchmarks you can run the following command:  $ vendor/bin/phpbench run --report=aggregate",
            "title": "Benchmarks"
        },
        {
            "location": "/quick-start/",
            "text": "Quick Start\n\n\nThe Service Manager is a modern, fast, and easy-to-use implementation of the\n\nService Locator design pattern\n.\nThe implementation implements the\n\nContainer Interop\n\ninterfaces, providing interoperability with other implementations.\n\n\nThe following is a \"quick start\" tutorial intended to get you up and running\nwith the most common features of the Service manager.\n\n\n1. Install Zend Service Manager\n\n\nIf you haven't already, \ninstall Composer\n. Once you\nhave, you can install the service manager:\n\n\n$ composer require zendframework/zend-servicemanager\n\n\n\n\n2. Configuring a service manager\n\n\nYou can now create and configure a service manager. The service manager\nconstructor accepts a simple array:\n\n\nuse Zend\\ServiceManager\\ServiceManager;\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\nuse stdClass;\n\n$serviceManager = new ServiceManager([\n    'factories' =\n [\n        stdClass::class =\n InvokableFactory::class,\n    ],\n]);\n\n\n\n\nThe service manager accepts a variety of keys; refer to the\n\nConfiguring service manager\n section for\nfull details.\n\n\n3. Retrieving objects\n\n\nFinally, you can retrieve instances using the \nget()\n method:\n\n\n$object = $serviceManager-\nget(stdClass::class);\n\n\n\n\nBy default, all objects created through the service manager are shared. This\nmeans that calling the \nget()\n method twice will return the exact same object:\n\n\n$object1 = $serviceManager-\nget(stdClass::class);\n$object2 = $serviceManager-\nget(stdClass::class);\n\nvar_dump($object1 === $object2); // prints \ntrue\n\n\n\n\nYou can use the \nbuild()\n method to retrieve discrete instances for a service:\n\n\n$object1 = $serviceManager-\nbuild(stdClass::class);\n$object2 = $serviceManager-\nbuild(stdClass::class);\n\nvar_dump($object1 === $object2); // prints \nfalse",
            "title": "Quick Start"
        },
        {
            "location": "/quick-start/#quick-start",
            "text": "The Service Manager is a modern, fast, and easy-to-use implementation of the Service Locator design pattern .\nThe implementation implements the Container Interop \ninterfaces, providing interoperability with other implementations.  The following is a \"quick start\" tutorial intended to get you up and running\nwith the most common features of the Service manager.",
            "title": "Quick Start"
        },
        {
            "location": "/quick-start/#1-install-zend-service-manager",
            "text": "If you haven't already,  install Composer . Once you\nhave, you can install the service manager:  $ composer require zendframework/zend-servicemanager",
            "title": "1. Install Zend Service Manager"
        },
        {
            "location": "/quick-start/#2-configuring-a-service-manager",
            "text": "You can now create and configure a service manager. The service manager\nconstructor accepts a simple array:  use Zend\\ServiceManager\\ServiceManager;\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\nuse stdClass;\n\n$serviceManager = new ServiceManager([\n    'factories' =  [\n        stdClass::class =  InvokableFactory::class,\n    ],\n]);  The service manager accepts a variety of keys; refer to the Configuring service manager  section for\nfull details.",
            "title": "2. Configuring a service manager"
        },
        {
            "location": "/quick-start/#3-retrieving-objects",
            "text": "Finally, you can retrieve instances using the  get()  method:  $object = $serviceManager- get(stdClass::class);  By default, all objects created through the service manager are shared. This\nmeans that calling the  get()  method twice will return the exact same object:  $object1 = $serviceManager- get(stdClass::class);\n$object2 = $serviceManager- get(stdClass::class);\n\nvar_dump($object1 === $object2); // prints  true  You can use the  build()  method to retrieve discrete instances for a service:  $object1 = $serviceManager- build(stdClass::class);\n$object2 = $serviceManager- build(stdClass::class);\n\nvar_dump($object1 === $object2); // prints  false",
            "title": "3. Retrieving objects"
        },
        {
            "location": "/configuring-the-service-manager/",
            "text": "Configuring the service manager\n\n\nThe Service Manager component can be configured by passing an associative array to the component's\nconstructor. The following keys are:\n\n\n\n\nservices\n: associative array that maps a key to a service instance.\n\n\nfactories\n: associative array that map a key to a factory name, or any callable.\n\n\nabstract_factories\n: a list of abstract factories classes. An abstract\n  factory is a factory that can potentially create any object, based on some\n  criterias.\n\n\ndelegators\n: TODO (delegators are described in their own section).\n\n\naliases\n: associative array that map a key to a service key (or another alias).\n\n\ninitializers\n: a list of callable or initializers that are run whenever a service has been created.\n\n\nshared\n: associative array that map a service name to a boolean, in order to\n  indicate the service manager if it should cache or not a service created\n  through the \nget\n method, independant of the \nshared_by_default\n setting.\n\n\nlazy_services\n: configuration for the lazy service proxy manager, and a class\n  map of service:class pairs that will act as lazy services; see the\n  \nlazy services documentation\n for more details.\n\n\nshared_by_default\n: boolean that indicates whether services created through\n  the \nget\n method should be cached. This is true by default.\n\n\n\n\nHere is an example of how you could configure a service manager:\n\n\nuse Zend\\ServiceManager\\ServiceManager;\n\n$serviceManager = new ServiceManager([\n    'services'           =\n [],\n    'factories'          =\n [],\n    'abstract_factories' =\n [],\n    'delegators'         =\n [],\n    'shared'             =\n [],\n    'shared_by_default'  =\n true\n]);\n\n\n\n\nFactories\n\n\nA factory is any callable or any class that implements the interface\n\nZend\\ServiceManager\\Factory\\FactoryInterface\n.\n\n\nService manager components provide a default factory that can be used to create\nobjects that do not have any dependencies:\n\n\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\nuse Zend\\ServiceManager\\ServiceManager;\nuse stdClass;\n\n$serviceManager = new ServiceManager([\n    'factories' =\n [\n        stdClass::class =\n InvokableFactory::class\n    ]\n]);\n\n\n\n\n\n\nThis mechanism replaces the \ninvokables\n key that was used in Zend Framework 2.\n\n\n\n\nAs said before, a factory can also be a callable, to create more complex objects:\n\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\nuse Zend\\ServiceManager\\ServiceManager;\nuse stdClass;\n\n$serviceManager = new ServiceManager([\n    'factories' =\n [\n        stdClass::class =\n InvokableFactory::class,\n        MyObject::class =\n function(ContainerInterface $container, $requestedName) {\n            $dependency = $container-\nget(stdClass::class);\n            return new MyObject($dependency);\n        },\n    ],\n]);\n\n\n\n\nEach factory always receive a \nContainerInterface\n argument (this is the base\ninterface that the \nServiceManager\n implements), as well as the requested name\nas the second argument. In this case, the \n$requestedName\n is \nMyObject\n.\n\n\nAlternatively, the above code can be replaced by a factory class instead of a\nclosure. This leads to more readable code. For instance:\n\n\n// In MyObjectFactory.php file\n\nclass MyObjectFactory implements FactoryInterface\n{\n    public function __invoke(ContainerInterface $container, $requestedName, array $options = null)\n    {\n        $dependency = $container-\nget(stdClass::class);\n        return new MyObject($dependency);\n    }\n}\n\n// When creating the service manager:\n$serviceManager = new ServiceManager([\n    'factories' =\n [\n        stdClass::class =\n InvokableFactory::class,\n        MyObject::class =\n MyObjectFactory::class\n    ]\n]);\n\n\n\n\n\n\nFor performance reasons, factories objects are not created until requested.\nIn the above example, this means that the \nMyObjectFactory\n object won't be\ncreated until \nMyObject\n is requested.\n\n\n\n\nMapping multiple service to the same factory\n\n\nUnlike version 2 implementations of the component, in the version 3\nimplementation, the \n$requestedName\n is guaranteed to be passed as the second\nparameter of a factory. This is useful when you need to create multiple\nservices that are created exactly the same way, hence reducing the number of\nneeded factories.\n\n\nFor instance, if two services share the same creation pattern, you could attach the same factory:\n\n\n// In MyObjectFactory.php file\n\nclass MyObjectFactory implements FactoryInterface\n{\n    public function __invoke(ContainerInterface $container, $requestedName, array $options = null)\n    {\n        $dependency = $container-\nget(stdClass::class);\n        return new $requestedName($dependency);\n    }\n}\n\n// When creating the service manager:\n$serviceManager = new ServiceManager([\n    'factories' =\n [\n        MyObjectA::class =\n MyObjectFactory::class,\n        MyObjectB::class =\n MyObjectFactory::class\n    ]\n]);\n\n\n\n\nThis pattern can often replace abstract factories, and is more performant:\n\n\n\n\nLookups for services do not need to query abstract factories; the service is\n  mapped explicitly.\n\n\nOnce the factory is loaded for any object, it stays in memory for any other\n  service using the same factory.\n\n\n\n\nUsing factories is recommended in most cases where abstract factories were used\nin version 2.\n\n\nThis feature \ncan\n be abused, however: for instance, if you have dozens of\nservices that share the same creation, but which do not share any common\nfunctionality, we recommend to create separate factories.\n\n\nAbstract factories\n\n\nAn abstract factory is a specialized factory that can be used to create any\nservice, if it has the capability to do so. An abstract factory is often useful\nwhen you do not know in advance the name of the service (e.g. if the service\nname is generated dynamically at runtime), but know that the services share a\ncommon creation pattern.\n\n\nAn abstract factory must be registered inside the service manager, and is\nchecked if no factory can create an object. Each abstract factory must\nimplement \nZend\\ServiceManager\\Factory\\AbstractFactoryInterface\n:\n\n\n// In MyAbstractFactory.php:\n\nclass MyAbstractFactory implements AbstractFactoryInterface\n{\n    public function canCreate(ContainerInterface $container, $requestedName)\n    {\n        return in_array('Traversable', class_implements($requestedName), true);\n    }\n\n    public function __invoke(ContainerInterface $container, $requestedName, array $options = null)\n    {\n        return $requestedName();\n    }\n}\n\n// When creating the service manager:\n$serviceManager = new ServiceManager([\n    'abstract_factories' =\n [\n        new MyAbstractFactory() // You could also pass a class name: MyAbstractFactory::class\n    ]\n]);\n\n// When fetching an object:\n$object = $serviceManager-\nget(A::class);\n\n\n\n\nHere is what will happen:\n\n\n\n\nThe service manager will check if it contains a factory mapped to the\n   \nA::class\n service.\n\n\nBecause none is found, it will process each abstract factory, in the order\n   in which they were registered.\n\n\nIt will call the \ncanCreate()\n method, passing the service manager instance and\n   the name of the requested object. The method can use any logic whatsoever to\n   determine if it can create the service (such as checking its name, checking\n   for a required dependency in the passed container, checking if a class\n   implements a given interface, etc.).\n\n\nIf \ncanCreate()\n returns \ntrue\n, it will call the \n__invoke\n method to\n   create the object. Otherwise, it will continue iterating the abstract\n   factories, until one matches, or the queue is exhausted.\n\n\n\n\nBest practices\n\n\nWhile convenient, we recommend you to limit the number of abstract factories.\nBecause the service manager needs to iterate through all registered abstract\nfactories to resolve services, it can be costly when multiple abstract\nfactories are present.\n\n\nOften, mapping the same factory to multiple services can solve the issue more\nefficiently (as described in the \nFactories\n section).\n\n\nAliases\n\n\nAn \nalias\n provides an alternative name for a registered service.\n\n\nAn alias can also be mapped to another alias (it will be resolved recursively).\nFor instance:\n\n\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\nuse Zend\\ServiceManager\\ServiceManager;\nuse stdClass;\n\n$serviceManager = new ServiceManager([\n    'factories' =\n [\n        stdClass::class =\n InvokableFactory::class\n    ],\n\n    'aliases' =\n [\n        'A' =\n stdClass::class,\n        'B' =\n 'A'\n    ]\n]);\n\n$object = $serviceManager-\nget('B');\n\n\n\n\nIn this example, asking \nB\n will be resolved to \nA\n, which will be itself\nresolved to \nstdClass::class\n, which will finally be constructed using the\nprovided factory.\n\n\nBest practices\n\n\nWe recommend you minimal use of aliases, and instead using the \n::class\n\nlanguage construct to map using a FQCN (Fully-Qualified-Class-Name). This\nprovides both better discoverability within your code, and allows simpler\nrefactoring, as most modern IDEs can refactor class names specified using the\n\n::class\n keyword.\n\n\nInitializers\n\n\nAn initializer is any callable or any class that implements the interface\n\nZend\\ServiceManager\\Initializer\\InitializerInterface\n. Initializers are\nexecuted for each service the first time they are created, and can be used to\ninject additional dependencies.\n\n\nFor instance, if we'd want to automatically inject the dependency\n\nEventManager::class\n in all objects that implement the interface\n\nEventManagerAwareInterface\n, we could create the following initializer:\n\n\nuse Interop\\Container\\ContainerInterface;\nuse stdClass;\nuse Zend\\ServiceManager\\ServiceManager;\n\n$serviceManager = new ServiceManager([\n    'initializers' =\n [\n        function(ContainerInterface $container, $instance) {\n            if (! $instance instanceof EventManagerAwareInterface) {\n                return;\n            }\n            $instance-\nsetEventManager($container-\nget(EventManager::class));\n        }\n    ]\n]);\n\n\n\n\nAlternately, you can create a class that implements\n\nZend\\ServiceManager\\Initializer\\InitializerInterface\n, and pass it to the\n\ninitializers\n array:\n\n\n// In MyInitializer.php\n\nclass MyInitializer implements InitializerInterface\n{\n    public function __invoke(ContainerInterface $container, $instance)\n    {\n        if (! $instance instanceof EventManagerAwareInterface) {\n            return;\n        }\n        $instance-\nsetEventManager($container-\nget(EventManager::class));\n    }\n}\n\n// When creating the service manager:\n\nuse Interop\\Container\\ContainerInterface;\nuse stdClass;\nuse Zend\\ServiceManager\\ServiceManager;\n\n$serviceManager = new ServiceManager([\n    'initializers' =\n [\n        new MyInitializer() // You could also use MyInitializer::class\n    ]\n]);\n\n\n\n\n\n\nNote that initializers are automatically created when the service manager is\ninitialized, even if you pass a class name.\n\n\n\n\nBest practices\n\n\nWhile convenient, initializer usage is also problematic. They are provided\nprimarily for backwards compatibility, but we highly discourage their usage.\n\n\nThe primary issues with initializers are:\n\n\n\n\nThey lead to fragile code. Because the dependency is not injected directly in\n  the constructor, it means that the object may be in an \"incomplete state\". If\n  for any reason the initializer is not run (if it was not correctly registered\n  for instance), bugs ranging from the subtle to fatal can be introduced.\n\n\n\n\nInstead, we encourage you to inject all necessary dependencies via\n  the constructor, using factories. If some dependencies use setter or interface\n  injection, use delegator factories.\n\n\nIf a given service has too many dependencies, then it may be a sign that you\n  need to split this service into smaller, more focused services.\n\n\n\n\nThey are slow: an initializer is run for EVERY instance you create through\n  the service manager. If you have ten initializers or more, this can quickly\n  add up!\n\n\n\n\nShared\n\n\nBy default, a service created is shared. This means that calling the \nget()\n\nmethod twice for a given service will return exactly the same service. This is\ntypically what you want, as it can saves a lot of memory and increase\nperformance:\n\n\n$serviceManager = new ServiceManager([\n    'factories' =\n [\n        stdClass::class =\n InvokableFactory::class\n    ]\n]);\n\n$object1 = $serviceManager-\nget(stdClass::class);\n$object2 = $serviceManager-\nget(stdClass::class);\n\nvar_dump($object1 === $object2); // prints \ntrue\n\n\n\n\nHowever, occasionally you may require discrete instances of a service. To\nenable this, you can use the \nshared\n key, providing a boolean false value for\nyour service, as shown below:\n\n\n$serviceManager = new ServiceManager([\n    'factories' =\n [\n        stdClass::class =\n InvokableFactory::class\n    ],\n    'shared' =\n [\n        stdClass::class =\n false\n    ]\n]);\n\n$object1 = $serviceManager-\nget(stdClass::class);\n$object2 = $serviceManager-\nget(stdClass::class);\n\nvar_dump($object1 === $object2); // prints \nfalse\n\n\n\n\nAlternately, you can use the \nbuild()\n method instead of the \nget()\n method.\nThe \nbuild()\n method works exactly the same as the \nget\n method, but never\ncaches the service created, nor uses a previously cached instance for the\nservice.\n\n\n$serviceManager = new ServiceManager([\n    'factories' =\n [\n        stdClass::class =\n InvokableFactory::class\n    ]\n]);\n\n$object1 = $serviceManager-\nbuild(stdClass::class);\n$object2 = $serviceManager-\nbuild(stdClass::class);\n\nvar_dump($object1 === $object2); // prints \nfalse\n\n\n\n\nFinally, you could also decide to disable caching by default (even when calling\nthe \nget()\n method), by setting the \nshared_by_default\n option to false:\n\n\n$serviceManager = new ServiceManager([\n    'factories' =\n [\n        stdClass::class =\n InvokableFactory::class\n    ],\n    'shared_by_default' =\n false,\n]);\n\n$object1 = $serviceManager-\nget(stdClass::class);\n$object2 = $serviceManager-\nget(stdClass::class);\n\nvar_dump($object1 === $object2); // prints \nfalse\n\n\n\n\nPassing config to a factory/delegator\n\n\nSo far, we have covered examples where services are created through factories\n(or abstract factories). The factory is able to create the object itself.\n\n\nOccasionally you may need to pass additional options that act as a \"context\".\nFor instance, we could have a \nStringLengthValidator\n service registered.\nHowever, this validator can have multiple options, such as \nmin\n and \nmax\n.\nBecause this is dependant on the caller context (or might even be retrieved\nfrom a database, for instance), the factory cannot know what options to give\nwhen constructing the validator.\n\n\nTo solve this issue, the service manager offers a \nbuild()\n method. It works\nsimilarly to the \nget()\n method, with two main differences:\n\n\n\n\nServices created with the \nbuild()\n method are \nnever cached\n, nor pulled\n  from previously cached instances for that service.\n\n\nbuild()\n accepts an optional secondary parameter, an array of options.\n\n\n\n\nThose options are transferred to all factories, abstract factories, and delegators.\nFor instance:\n\n\n// In StringLengthValidatorFactory.php\n\nclass StringLengthValidatorFactory implements FactoryInterface\n{\n    public function __invoke(ContainerInterface $container, $requestedName, array $options = [])\n    {\n        return new StringLengthValidator($options);\n    }\n}\n\n// When creating the service manager:\n$serviceManager = new ServiceManager([\n    'factories' =\n [\n        StringLengthValidator::class =\n StringLengthValidatorFactory::class\n    ]\n]);\n\n// When creating the objects:\n\n$validator1 = $serviceManager-\nbuild(StringLengthValidator::class, ['min' =\n 5]);\n$validator2 = $serviceManager-\nbuild(StringLengthValidator::class, ['min' =\n 15]);\n\n\n\n\nIn our previous example, because the \nStringLengthValidator\n does not have any\nother dependencies other than the \n$options\n, we could remove the factory, and\nsimply map it to the built-in \nInvokableFactory\n factory:\n\n\n// When creating the service manager:\n$serviceManager = new ServiceManager([\n    'factories' =\n [\n        StringLengthValidator::class =\n InvokableFactory::class\n    ]\n]);\n\n// When creating the objects:\n\n$validator1 = $serviceManager-\nbuild(StringLengthValidator::class, ['min' =\n 5]);\n$validator2 = $serviceManager-\nbuild(StringLengthValidator::class, ['min' =\n 15]);\n\n\n\n\nThis works because the \nInvokableFactory\n will automatically pass the options\n(if any) to the constructor of the created object.\n\n\nAltering a service manager's config\n\n\nAssuming that you have not called \n$container-\nsetAllowOverride(false)\n, you can,\nat any time, configure the service manager with new services using any of the\nfollowing methods:\n\n\n\n\nconfigure()\n, which accepts the same configuration array as the constructor.\n\n\nsetAlias($alias, $target)\n\n\nsetInvokableClass($name, $class = null)\n; if no \n$class\n is passed, the\n  assumption is that \n$name\n is the class name.\n\n\nsetFactory($name, $factory)\n, where \n$factory\n can be either a callable\n  factory or the name of a factory class to use.\n\n\nmapLazyService($name, $class = null)\n, to map the service name \n$name\n to\n  \n$class\n; if the latter is not provided, \n$name\n is used for both sides of\n  the map.\n\n\naddAbstractFactory($factory)\n, where \n$factory\n can be either a\n  \nZend\\ServiceManager\\Factory\\AbstractFactoryInterface\n instance or the name\n  of a class implementing the interface.\n\n\naddDelegator($name, $factory)\n, where \n$factory\n can be either a callable\n  delegator factory, or the name of a delegator factory class to use.\n\n\naddInitializer($initializer)\n, where \n$initializer\n can be either a callable\n  initializer, or the name of an initializer class to use.\n\n\nsetService($name, $instance)\n\n\nsetShared($name, $shared)\n, where \n$shared\n is a boolean flag indicating\n  whether or not the named service should be shared.\n\n\n\n\nAs examples:\n\n\nuse Zend\\ServiceManager\\ServiceManager;\n\n$serviceManager = new ServiceManager([\n    'factories' =\n [\n        stdClass::class =\n InvokableFactory::class;\n    ]\n]);\n\n$serviceManager-\nconfigure([\n    'factories' =\n [\n        DateTime::class =\n InvokableFactory::class\n    ]\n]);\n\nvar_dump($newServiceManager-\nhas(DateTime::class)); // prints true\n\n// Create an alias from 'Date' to 'DateTime'\n$serviceManager-\nsetAlias('Date', DateTime::class);\n\n// Set a factory for the 'Time' service\n$serviceManager-\nsetFactory('Time', function ($container) {\n    return $container-\nget(DateTime::class);\n});\n\n// Map a lazy service named 'localtime' to the class DateTime.\n$serviceManager-\nmapLazyService('localtime', DateTime::class);\n\n// Add an abstract factory\n$serviceManager-\naddAbstractFactory(new CustomAbstractFactory());\n\n// Add a delegator factory for the DateTime service\n$serviceManager-\naddDelegator(DateTime::class, function ($container, $name, $callback) {\n    $dateTime = $callback();\n    $dataTime-\nsetTimezone(new DateTimezone('UTC'));\n    return $dateTime;\n});\n\n// Add an initializer\n// Note: don't do this. Use delegator factories instead.\n$serviceManager-\naddInitializer(function ($service, $instance) {\n    if (! $instance instanceof DateTime) {\n        return;\n    }\n    $instance-\nsetTimezone(new DateTimezone('America/Chicago'));\n})\n\n// Explicitly map a service name to an instance.\n$serviceManager-\nsetService('foo', new stdClass);\n\n// Mark the DateTime service as NOT being shared.\n$serviceManager-\nsetShared(DateTime::class, false);",
            "title": "Configuring the service manager"
        },
        {
            "location": "/configuring-the-service-manager/#configuring-the-service-manager",
            "text": "The Service Manager component can be configured by passing an associative array to the component's\nconstructor. The following keys are:   services : associative array that maps a key to a service instance.  factories : associative array that map a key to a factory name, or any callable.  abstract_factories : a list of abstract factories classes. An abstract\n  factory is a factory that can potentially create any object, based on some\n  criterias.  delegators : TODO (delegators are described in their own section).  aliases : associative array that map a key to a service key (or another alias).  initializers : a list of callable or initializers that are run whenever a service has been created.  shared : associative array that map a service name to a boolean, in order to\n  indicate the service manager if it should cache or not a service created\n  through the  get  method, independant of the  shared_by_default  setting.  lazy_services : configuration for the lazy service proxy manager, and a class\n  map of service:class pairs that will act as lazy services; see the\n   lazy services documentation  for more details.  shared_by_default : boolean that indicates whether services created through\n  the  get  method should be cached. This is true by default.   Here is an example of how you could configure a service manager:  use Zend\\ServiceManager\\ServiceManager;\n\n$serviceManager = new ServiceManager([\n    'services'           =  [],\n    'factories'          =  [],\n    'abstract_factories' =  [],\n    'delegators'         =  [],\n    'shared'             =  [],\n    'shared_by_default'  =  true\n]);",
            "title": "Configuring the service manager"
        },
        {
            "location": "/configuring-the-service-manager/#factories",
            "text": "A factory is any callable or any class that implements the interface Zend\\ServiceManager\\Factory\\FactoryInterface .  Service manager components provide a default factory that can be used to create\nobjects that do not have any dependencies:  use Zend\\ServiceManager\\Factory\\InvokableFactory;\nuse Zend\\ServiceManager\\ServiceManager;\nuse stdClass;\n\n$serviceManager = new ServiceManager([\n    'factories' =  [\n        stdClass::class =  InvokableFactory::class\n    ]\n]);   This mechanism replaces the  invokables  key that was used in Zend Framework 2.   As said before, a factory can also be a callable, to create more complex objects:  use Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\nuse Zend\\ServiceManager\\ServiceManager;\nuse stdClass;\n\n$serviceManager = new ServiceManager([\n    'factories' =  [\n        stdClass::class =  InvokableFactory::class,\n        MyObject::class =  function(ContainerInterface $container, $requestedName) {\n            $dependency = $container- get(stdClass::class);\n            return new MyObject($dependency);\n        },\n    ],\n]);  Each factory always receive a  ContainerInterface  argument (this is the base\ninterface that the  ServiceManager  implements), as well as the requested name\nas the second argument. In this case, the  $requestedName  is  MyObject .  Alternatively, the above code can be replaced by a factory class instead of a\nclosure. This leads to more readable code. For instance:  // In MyObjectFactory.php file\n\nclass MyObjectFactory implements FactoryInterface\n{\n    public function __invoke(ContainerInterface $container, $requestedName, array $options = null)\n    {\n        $dependency = $container- get(stdClass::class);\n        return new MyObject($dependency);\n    }\n}\n\n// When creating the service manager:\n$serviceManager = new ServiceManager([\n    'factories' =  [\n        stdClass::class =  InvokableFactory::class,\n        MyObject::class =  MyObjectFactory::class\n    ]\n]);   For performance reasons, factories objects are not created until requested.\nIn the above example, this means that the  MyObjectFactory  object won't be\ncreated until  MyObject  is requested.",
            "title": "Factories"
        },
        {
            "location": "/configuring-the-service-manager/#mapping-multiple-service-to-the-same-factory",
            "text": "Unlike version 2 implementations of the component, in the version 3\nimplementation, the  $requestedName  is guaranteed to be passed as the second\nparameter of a factory. This is useful when you need to create multiple\nservices that are created exactly the same way, hence reducing the number of\nneeded factories.  For instance, if two services share the same creation pattern, you could attach the same factory:  // In MyObjectFactory.php file\n\nclass MyObjectFactory implements FactoryInterface\n{\n    public function __invoke(ContainerInterface $container, $requestedName, array $options = null)\n    {\n        $dependency = $container- get(stdClass::class);\n        return new $requestedName($dependency);\n    }\n}\n\n// When creating the service manager:\n$serviceManager = new ServiceManager([\n    'factories' =  [\n        MyObjectA::class =  MyObjectFactory::class,\n        MyObjectB::class =  MyObjectFactory::class\n    ]\n]);  This pattern can often replace abstract factories, and is more performant:   Lookups for services do not need to query abstract factories; the service is\n  mapped explicitly.  Once the factory is loaded for any object, it stays in memory for any other\n  service using the same factory.   Using factories is recommended in most cases where abstract factories were used\nin version 2.  This feature  can  be abused, however: for instance, if you have dozens of\nservices that share the same creation, but which do not share any common\nfunctionality, we recommend to create separate factories.",
            "title": "Mapping multiple service to the same factory"
        },
        {
            "location": "/configuring-the-service-manager/#abstract-factories",
            "text": "An abstract factory is a specialized factory that can be used to create any\nservice, if it has the capability to do so. An abstract factory is often useful\nwhen you do not know in advance the name of the service (e.g. if the service\nname is generated dynamically at runtime), but know that the services share a\ncommon creation pattern.  An abstract factory must be registered inside the service manager, and is\nchecked if no factory can create an object. Each abstract factory must\nimplement  Zend\\ServiceManager\\Factory\\AbstractFactoryInterface :  // In MyAbstractFactory.php:\n\nclass MyAbstractFactory implements AbstractFactoryInterface\n{\n    public function canCreate(ContainerInterface $container, $requestedName)\n    {\n        return in_array('Traversable', class_implements($requestedName), true);\n    }\n\n    public function __invoke(ContainerInterface $container, $requestedName, array $options = null)\n    {\n        return $requestedName();\n    }\n}\n\n// When creating the service manager:\n$serviceManager = new ServiceManager([\n    'abstract_factories' =  [\n        new MyAbstractFactory() // You could also pass a class name: MyAbstractFactory::class\n    ]\n]);\n\n// When fetching an object:\n$object = $serviceManager- get(A::class);  Here is what will happen:   The service manager will check if it contains a factory mapped to the\n    A::class  service.  Because none is found, it will process each abstract factory, in the order\n   in which they were registered.  It will call the  canCreate()  method, passing the service manager instance and\n   the name of the requested object. The method can use any logic whatsoever to\n   determine if it can create the service (such as checking its name, checking\n   for a required dependency in the passed container, checking if a class\n   implements a given interface, etc.).  If  canCreate()  returns  true , it will call the  __invoke  method to\n   create the object. Otherwise, it will continue iterating the abstract\n   factories, until one matches, or the queue is exhausted.",
            "title": "Abstract factories"
        },
        {
            "location": "/configuring-the-service-manager/#best-practices",
            "text": "While convenient, we recommend you to limit the number of abstract factories.\nBecause the service manager needs to iterate through all registered abstract\nfactories to resolve services, it can be costly when multiple abstract\nfactories are present.  Often, mapping the same factory to multiple services can solve the issue more\nefficiently (as described in the  Factories  section).",
            "title": "Best practices"
        },
        {
            "location": "/configuring-the-service-manager/#aliases",
            "text": "An  alias  provides an alternative name for a registered service.  An alias can also be mapped to another alias (it will be resolved recursively).\nFor instance:  use Zend\\ServiceManager\\Factory\\InvokableFactory;\nuse Zend\\ServiceManager\\ServiceManager;\nuse stdClass;\n\n$serviceManager = new ServiceManager([\n    'factories' =  [\n        stdClass::class =  InvokableFactory::class\n    ],\n\n    'aliases' =  [\n        'A' =  stdClass::class,\n        'B' =  'A'\n    ]\n]);\n\n$object = $serviceManager- get('B');  In this example, asking  B  will be resolved to  A , which will be itself\nresolved to  stdClass::class , which will finally be constructed using the\nprovided factory.",
            "title": "Aliases"
        },
        {
            "location": "/configuring-the-service-manager/#best-practices_1",
            "text": "We recommend you minimal use of aliases, and instead using the  ::class \nlanguage construct to map using a FQCN (Fully-Qualified-Class-Name). This\nprovides both better discoverability within your code, and allows simpler\nrefactoring, as most modern IDEs can refactor class names specified using the ::class  keyword.",
            "title": "Best practices"
        },
        {
            "location": "/configuring-the-service-manager/#initializers",
            "text": "An initializer is any callable or any class that implements the interface Zend\\ServiceManager\\Initializer\\InitializerInterface . Initializers are\nexecuted for each service the first time they are created, and can be used to\ninject additional dependencies.  For instance, if we'd want to automatically inject the dependency EventManager::class  in all objects that implement the interface EventManagerAwareInterface , we could create the following initializer:  use Interop\\Container\\ContainerInterface;\nuse stdClass;\nuse Zend\\ServiceManager\\ServiceManager;\n\n$serviceManager = new ServiceManager([\n    'initializers' =  [\n        function(ContainerInterface $container, $instance) {\n            if (! $instance instanceof EventManagerAwareInterface) {\n                return;\n            }\n            $instance- setEventManager($container- get(EventManager::class));\n        }\n    ]\n]);  Alternately, you can create a class that implements Zend\\ServiceManager\\Initializer\\InitializerInterface , and pass it to the initializers  array:  // In MyInitializer.php\n\nclass MyInitializer implements InitializerInterface\n{\n    public function __invoke(ContainerInterface $container, $instance)\n    {\n        if (! $instance instanceof EventManagerAwareInterface) {\n            return;\n        }\n        $instance- setEventManager($container- get(EventManager::class));\n    }\n}\n\n// When creating the service manager:\n\nuse Interop\\Container\\ContainerInterface;\nuse stdClass;\nuse Zend\\ServiceManager\\ServiceManager;\n\n$serviceManager = new ServiceManager([\n    'initializers' =  [\n        new MyInitializer() // You could also use MyInitializer::class\n    ]\n]);   Note that initializers are automatically created when the service manager is\ninitialized, even if you pass a class name.",
            "title": "Initializers"
        },
        {
            "location": "/configuring-the-service-manager/#best-practices_2",
            "text": "While convenient, initializer usage is also problematic. They are provided\nprimarily for backwards compatibility, but we highly discourage their usage.  The primary issues with initializers are:   They lead to fragile code. Because the dependency is not injected directly in\n  the constructor, it means that the object may be in an \"incomplete state\". If\n  for any reason the initializer is not run (if it was not correctly registered\n  for instance), bugs ranging from the subtle to fatal can be introduced.   Instead, we encourage you to inject all necessary dependencies via\n  the constructor, using factories. If some dependencies use setter or interface\n  injection, use delegator factories.  If a given service has too many dependencies, then it may be a sign that you\n  need to split this service into smaller, more focused services.   They are slow: an initializer is run for EVERY instance you create through\n  the service manager. If you have ten initializers or more, this can quickly\n  add up!",
            "title": "Best practices"
        },
        {
            "location": "/configuring-the-service-manager/#shared",
            "text": "By default, a service created is shared. This means that calling the  get() \nmethod twice for a given service will return exactly the same service. This is\ntypically what you want, as it can saves a lot of memory and increase\nperformance:  $serviceManager = new ServiceManager([\n    'factories' =  [\n        stdClass::class =  InvokableFactory::class\n    ]\n]);\n\n$object1 = $serviceManager- get(stdClass::class);\n$object2 = $serviceManager- get(stdClass::class);\n\nvar_dump($object1 === $object2); // prints  true  However, occasionally you may require discrete instances of a service. To\nenable this, you can use the  shared  key, providing a boolean false value for\nyour service, as shown below:  $serviceManager = new ServiceManager([\n    'factories' =  [\n        stdClass::class =  InvokableFactory::class\n    ],\n    'shared' =  [\n        stdClass::class =  false\n    ]\n]);\n\n$object1 = $serviceManager- get(stdClass::class);\n$object2 = $serviceManager- get(stdClass::class);\n\nvar_dump($object1 === $object2); // prints  false  Alternately, you can use the  build()  method instead of the  get()  method.\nThe  build()  method works exactly the same as the  get  method, but never\ncaches the service created, nor uses a previously cached instance for the\nservice.  $serviceManager = new ServiceManager([\n    'factories' =  [\n        stdClass::class =  InvokableFactory::class\n    ]\n]);\n\n$object1 = $serviceManager- build(stdClass::class);\n$object2 = $serviceManager- build(stdClass::class);\n\nvar_dump($object1 === $object2); // prints  false  Finally, you could also decide to disable caching by default (even when calling\nthe  get()  method), by setting the  shared_by_default  option to false:  $serviceManager = new ServiceManager([\n    'factories' =  [\n        stdClass::class =  InvokableFactory::class\n    ],\n    'shared_by_default' =  false,\n]);\n\n$object1 = $serviceManager- get(stdClass::class);\n$object2 = $serviceManager- get(stdClass::class);\n\nvar_dump($object1 === $object2); // prints  false",
            "title": "Shared"
        },
        {
            "location": "/configuring-the-service-manager/#passing-config-to-a-factorydelegator",
            "text": "So far, we have covered examples where services are created through factories\n(or abstract factories). The factory is able to create the object itself.  Occasionally you may need to pass additional options that act as a \"context\".\nFor instance, we could have a  StringLengthValidator  service registered.\nHowever, this validator can have multiple options, such as  min  and  max .\nBecause this is dependant on the caller context (or might even be retrieved\nfrom a database, for instance), the factory cannot know what options to give\nwhen constructing the validator.  To solve this issue, the service manager offers a  build()  method. It works\nsimilarly to the  get()  method, with two main differences:   Services created with the  build()  method are  never cached , nor pulled\n  from previously cached instances for that service.  build()  accepts an optional secondary parameter, an array of options.   Those options are transferred to all factories, abstract factories, and delegators.\nFor instance:  // In StringLengthValidatorFactory.php\n\nclass StringLengthValidatorFactory implements FactoryInterface\n{\n    public function __invoke(ContainerInterface $container, $requestedName, array $options = [])\n    {\n        return new StringLengthValidator($options);\n    }\n}\n\n// When creating the service manager:\n$serviceManager = new ServiceManager([\n    'factories' =  [\n        StringLengthValidator::class =  StringLengthValidatorFactory::class\n    ]\n]);\n\n// When creating the objects:\n\n$validator1 = $serviceManager- build(StringLengthValidator::class, ['min' =  5]);\n$validator2 = $serviceManager- build(StringLengthValidator::class, ['min' =  15]);  In our previous example, because the  StringLengthValidator  does not have any\nother dependencies other than the  $options , we could remove the factory, and\nsimply map it to the built-in  InvokableFactory  factory:  // When creating the service manager:\n$serviceManager = new ServiceManager([\n    'factories' =  [\n        StringLengthValidator::class =  InvokableFactory::class\n    ]\n]);\n\n// When creating the objects:\n\n$validator1 = $serviceManager- build(StringLengthValidator::class, ['min' =  5]);\n$validator2 = $serviceManager- build(StringLengthValidator::class, ['min' =  15]);  This works because the  InvokableFactory  will automatically pass the options\n(if any) to the constructor of the created object.",
            "title": "Passing config to a factory/delegator"
        },
        {
            "location": "/configuring-the-service-manager/#altering-a-service-managers-config",
            "text": "Assuming that you have not called  $container- setAllowOverride(false) , you can,\nat any time, configure the service manager with new services using any of the\nfollowing methods:   configure() , which accepts the same configuration array as the constructor.  setAlias($alias, $target)  setInvokableClass($name, $class = null) ; if no  $class  is passed, the\n  assumption is that  $name  is the class name.  setFactory($name, $factory) , where  $factory  can be either a callable\n  factory or the name of a factory class to use.  mapLazyService($name, $class = null) , to map the service name  $name  to\n   $class ; if the latter is not provided,  $name  is used for both sides of\n  the map.  addAbstractFactory($factory) , where  $factory  can be either a\n   Zend\\ServiceManager\\Factory\\AbstractFactoryInterface  instance or the name\n  of a class implementing the interface.  addDelegator($name, $factory) , where  $factory  can be either a callable\n  delegator factory, or the name of a delegator factory class to use.  addInitializer($initializer) , where  $initializer  can be either a callable\n  initializer, or the name of an initializer class to use.  setService($name, $instance)  setShared($name, $shared) , where  $shared  is a boolean flag indicating\n  whether or not the named service should be shared.   As examples:  use Zend\\ServiceManager\\ServiceManager;\n\n$serviceManager = new ServiceManager([\n    'factories' =  [\n        stdClass::class =  InvokableFactory::class;\n    ]\n]);\n\n$serviceManager- configure([\n    'factories' =  [\n        DateTime::class =  InvokableFactory::class\n    ]\n]);\n\nvar_dump($newServiceManager- has(DateTime::class)); // prints true\n\n// Create an alias from 'Date' to 'DateTime'\n$serviceManager- setAlias('Date', DateTime::class);\n\n// Set a factory for the 'Time' service\n$serviceManager- setFactory('Time', function ($container) {\n    return $container- get(DateTime::class);\n});\n\n// Map a lazy service named 'localtime' to the class DateTime.\n$serviceManager- mapLazyService('localtime', DateTime::class);\n\n// Add an abstract factory\n$serviceManager- addAbstractFactory(new CustomAbstractFactory());\n\n// Add a delegator factory for the DateTime service\n$serviceManager- addDelegator(DateTime::class, function ($container, $name, $callback) {\n    $dateTime = $callback();\n    $dataTime- setTimezone(new DateTimezone('UTC'));\n    return $dateTime;\n});\n\n// Add an initializer\n// Note: don't do this. Use delegator factories instead.\n$serviceManager- addInitializer(function ($service, $instance) {\n    if (! $instance instanceof DateTime) {\n        return;\n    }\n    $instance- setTimezone(new DateTimezone('America/Chicago'));\n})\n\n// Explicitly map a service name to an instance.\n$serviceManager- setService('foo', new stdClass);\n\n// Mark the DateTime service as NOT being shared.\n$serviceManager- setShared(DateTime::class, false);",
            "title": "Altering a service manager's config"
        },
        {
            "location": "/delegators/",
            "text": "Delegators\n\n\nZend\\ServiceManager\n can instantiate \ndelegators\n\nof requested services, decorating them as specified in a delegate factory\nimplementing the \ndelegator factory interface\n.\n\n\nThe delegate pattern is useful in cases when you want to wrap a real service in\na \ndecorator\n, or generally\nintercept actions being performed on the delegate in an\n\nAOP\n fashioned way.\n\n\nDelegator factory signature\n\n\nA delegator factory has the following signature:\n\n\nuse Interop\\Container\\ContainerInterface;\n\npublic function __invoke(\n    ContainerInterface $container,\n    $name,\n    callable $callback,\n    array $options = null\n);\n\n\n\n\nThe parameters passed to the delegator factory are the following:\n\n\n\n\n$container\n is the service locator that is used while creating the delegator\n  for the requested service.\n\n\n$name\n is the name of the service being requested.\n\n\n$callback\n is a\n\n\ncallable\n that is\n  responsible for instantiating the delegated service (the real service instance).\n\n\n$options\n is an array of options to use when creating the instance; these are\n  typically used only during \nbuild()\n operations.\n\n\n\n\nA Delegator factory use case\n\n\nA typical use case for delegators is to handle logic before or after a method is\ncalled.\n\n\nIn the following example, an event is being triggered before \nBuzzer::buzz()\n is\ncalled and some output text is prepended.\n\n\nThe delegated object \nBuzzer\n (original object) is defined as following:\n\n\nclass Buzzer\n{\n    public function buzz()\n    {\n        return 'Buzz!';\n    }\n}\n\n\n\n\nThe delegator class \nBuzzerDelegator\n has the following structure:\n\n\nuse Zend\\EventManager\\EventManagerInterface;\n\nclass BuzzerDelegator extends Buzzer\n{\n    protected $realBuzzer;\n    protected $eventManager;\n\n    public function __construct(Buzzer $realBuzzer, EventManagerInterface $eventManager)\n    {\n        $this-\nrealBuzzer   = $realBuzzer;\n        $this-\neventManager = $eventManager;\n    }\n\n    public function buzz()\n    {\n        $this-\neventManager-\ntrigger('buzz', $this);\n\n        return $this-\nrealBuzzer-\nbuzz();\n    }\n}\n\n\n\n\nTo use the \nBuzzerDelegator\n, you can run the following code:\n\n\n$wrappedBuzzer = new Buzzer();\n$eventManager  = new Zend\\EventManager\\EventManager();\n\n$eventManager-\nattach('buzz', function () { echo \nStare at the art!\\n\n; });\n\n$buzzer = new BuzzerDelegator($wrappedBuzzer, $eventManager);\n\necho $buzzer-\nbuzz(); // \nStare at the art!\\nBuzz!\n\n\n\n\nThis logic is fairly simple as long as you have access to the instantiation\nlogic of the \n$wrappedBuzzer\n object.\n\n\nYou may not always be able to define how \n$wrappedBuzzer\n is created, since a\nfactory for it may be defined by some code to which you don't have access, or\nwhich you cannot modify without introducing further complexity.\n\n\nDelegator factories solve this specific problem by allowing you to wrap,\ndecorate or modify any existing service.\n\n\nA simple delegator factory for the \nbuzzer\n service can be implemented as\nfollowing:\n\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Factory\\DelegatorFactoryInterface;\n\nclass BuzzerDelegatorFactory implements DelegatorFactoryInterface\n{\n    public function __invoke(ContainerInterface $container, $name, callable $callback, array $options = null)\n    {\n        $realBuzzer   = call_user_func($callback);\n        $eventManager = $serviceLocator-\nget('EventManager');\n\n        $eventManager-\nattach('buzz', function () { echo \nStare at the art!\\n\n; });\n\n        return new BuzzerDelegator($realBuzzer, $eventManager);\n    }\n}\n\n\n\n\nYou can then instruct the service manager to handle the service \nbuzzer\n as a\ndelegate:\n\n\nuse Zend\\ServiceManager\\Factory\\InvokableClass;\nuse Zend\\ServiceManager\\ServiceManager;\n\n$serviceManager = new Zend\\ServiceManager\\ServiceManager([\n    'factories' =\n [\n        Buzzer::class =\n InvokableClass::class,\n    ],\n    'delegators' =\n [\n        Buzzer::class =\n [\n            BuzzerDelegatorFactory::class,\n        ],\n    ],\n]);\n\n// now, when fetching Buzzer, we get a BuzzerDelegator instead\n$buzzer = $serviceManager-\nget(Buzzer::class);\n\n$buzzer-\nbuzz(); // \nStare at the art!\\nBuzz!\n\n\n\n\nYou can specify multiple delegators for a service. Each will add one decorator\naround the instantiation logic of that particular service.\n\n\nThis latter point is the primary use case for delegators: \ndecorating the\ninstantiation logic for a service\n.",
            "title": "Delegators"
        },
        {
            "location": "/delegators/#delegators",
            "text": "Zend\\ServiceManager  can instantiate  delegators \nof requested services, decorating them as specified in a delegate factory\nimplementing the  delegator factory interface .  The delegate pattern is useful in cases when you want to wrap a real service in\na  decorator , or generally\nintercept actions being performed on the delegate in an AOP  fashioned way.",
            "title": "Delegators"
        },
        {
            "location": "/delegators/#delegator-factory-signature",
            "text": "A delegator factory has the following signature:  use Interop\\Container\\ContainerInterface;\n\npublic function __invoke(\n    ContainerInterface $container,\n    $name,\n    callable $callback,\n    array $options = null\n);  The parameters passed to the delegator factory are the following:   $container  is the service locator that is used while creating the delegator\n  for the requested service.  $name  is the name of the service being requested.  $callback  is a  callable  that is\n  responsible for instantiating the delegated service (the real service instance).  $options  is an array of options to use when creating the instance; these are\n  typically used only during  build()  operations.",
            "title": "Delegator factory signature"
        },
        {
            "location": "/delegators/#a-delegator-factory-use-case",
            "text": "A typical use case for delegators is to handle logic before or after a method is\ncalled.  In the following example, an event is being triggered before  Buzzer::buzz()  is\ncalled and some output text is prepended.  The delegated object  Buzzer  (original object) is defined as following:  class Buzzer\n{\n    public function buzz()\n    {\n        return 'Buzz!';\n    }\n}  The delegator class  BuzzerDelegator  has the following structure:  use Zend\\EventManager\\EventManagerInterface;\n\nclass BuzzerDelegator extends Buzzer\n{\n    protected $realBuzzer;\n    protected $eventManager;\n\n    public function __construct(Buzzer $realBuzzer, EventManagerInterface $eventManager)\n    {\n        $this- realBuzzer   = $realBuzzer;\n        $this- eventManager = $eventManager;\n    }\n\n    public function buzz()\n    {\n        $this- eventManager- trigger('buzz', $this);\n\n        return $this- realBuzzer- buzz();\n    }\n}  To use the  BuzzerDelegator , you can run the following code:  $wrappedBuzzer = new Buzzer();\n$eventManager  = new Zend\\EventManager\\EventManager();\n\n$eventManager- attach('buzz', function () { echo  Stare at the art!\\n ; });\n\n$buzzer = new BuzzerDelegator($wrappedBuzzer, $eventManager);\n\necho $buzzer- buzz(); //  Stare at the art!\\nBuzz!  This logic is fairly simple as long as you have access to the instantiation\nlogic of the  $wrappedBuzzer  object.  You may not always be able to define how  $wrappedBuzzer  is created, since a\nfactory for it may be defined by some code to which you don't have access, or\nwhich you cannot modify without introducing further complexity.  Delegator factories solve this specific problem by allowing you to wrap,\ndecorate or modify any existing service.  A simple delegator factory for the  buzzer  service can be implemented as\nfollowing:  use Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Factory\\DelegatorFactoryInterface;\n\nclass BuzzerDelegatorFactory implements DelegatorFactoryInterface\n{\n    public function __invoke(ContainerInterface $container, $name, callable $callback, array $options = null)\n    {\n        $realBuzzer   = call_user_func($callback);\n        $eventManager = $serviceLocator- get('EventManager');\n\n        $eventManager- attach('buzz', function () { echo  Stare at the art!\\n ; });\n\n        return new BuzzerDelegator($realBuzzer, $eventManager);\n    }\n}  You can then instruct the service manager to handle the service  buzzer  as a\ndelegate:  use Zend\\ServiceManager\\Factory\\InvokableClass;\nuse Zend\\ServiceManager\\ServiceManager;\n\n$serviceManager = new Zend\\ServiceManager\\ServiceManager([\n    'factories' =  [\n        Buzzer::class =  InvokableClass::class,\n    ],\n    'delegators' =  [\n        Buzzer::class =  [\n            BuzzerDelegatorFactory::class,\n        ],\n    ],\n]);\n\n// now, when fetching Buzzer, we get a BuzzerDelegator instead\n$buzzer = $serviceManager- get(Buzzer::class);\n\n$buzzer- buzz(); //  Stare at the art!\\nBuzz!  You can specify multiple delegators for a service. Each will add one decorator\naround the instantiation logic of that particular service.  This latter point is the primary use case for delegators:  decorating the\ninstantiation logic for a service .",
            "title": "A Delegator factory use case"
        },
        {
            "location": "/lazy-services/",
            "text": "Lazy Services\n\n\nZend\\ServiceManager\n can use \ndelegator factories\n to generate\n\"lazy\" references to your services.\n\n\nLazy services are \nproxies\n that\nget lazily instantiated, and keep a reference to the real instance of\nthe proxied service.\n\n\nUse cases\n\n\nYou may want to lazily initialize a service when it is instantiated very often,\nbut not always used.\n\n\nA typical example is a database connection: it is a dependency to many other\nelements in your application, but that doesn't mean that every request will\nexecute queries through it.\n\n\nAdditionally, instantiating a connection to the database may require some time\nand eat up resources.\n\n\nProxying the database connection would allow to delay that overhead until the\nobject is really needed.\n\n\nSetup\n\n\nZend\\ServiceManager\\Proxy\\LazyServiceFactory\n is a \ndelegator factory\n\ncapable of generating lazy loading proxies for your services.\n\n\nThe lazy service facilities depend on \nProxyManager\n;\nyou will need to install that package before using the feature:\n\n\n$ composer require ocramius/proxy-manager\n\n\n\n\nPractical example\n\n\nTo demonstrate how a lazy service works, you may use the following \nBuzzer\n\nexample class, which is designed to be slow at instantiation time for\ndemonstration purposes:\n\n\nnamespace MyApp;\n\nclass Buzzer\n{\n    public function __construct()\n    {\n        // deliberately halting the application for 5 seconds\n        sleep(5);\n    }\n\n    public function buzz()\n    {\n        return 'Buzz!';\n    }\n}\n\n\n\n\nYou can then proceed and configure the service manager to generate proxies\ninstead of real services:\n\n\nuse MyApp\\Buzzer;\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\nuse Zend\\ServiceManager\\Proxy\\LazyServiceFactory;\nuse Zend\\ServiceManager\\ServiceManager;\n\n$serviceManager = new \\Zend\\ServiceManager\\ServiceManager([\n    'factories' =\n [\n        Buzzer::class             =\n InvokableFactory::class,\n    ],\n    'lazy_services' =\n [\n         // Mapping services to their class names is required\n         // since the ServiceManager is not a declarative DIC.\n         'class_map' =\n [\n             Buzzer::class =\n Buzzer::class,\n         ],\n    ],\n    'delegators' =\n [\n        Buzzer::class =\n [\n            LazyServiceFactory::class,\n        ],\n    ],\n]);\n\n\n\n\nThis configuration tells the service manager to add the add\n\nLazyServiceFactory\n as a delegator for \nBuzzer\n.\n\n\nYou can now retrieve the buzzer:\n\n\nuse MyApp\\Buzzer;\n\n$buzzer = $serviceManager-\nget(Buzzer::class);\necho $buzzer-\nbuzz();\n\n\n\n\nTo verify that the proxying occurred correctly, you can run the following code,\nwhich should delay the 5 seconds wait time hardcoded in \nBuzzer::__construct\n\nuntil \nBuzzer::buzz\n is invoked:\n\n\nuse MyApp\\Buzzer;\n\nfor ($i = 0; $i \n 100; $i += 1) {\n    $buzzer = $serviceManager-\nget(Buzzer::class);\n    echo \ncreated buzzer $i\\n\n;\n}\n\necho $buzzer-\nbuzz();\n\n\n\n\nConfiguration\n\n\nThis is the config structure expected by \nZend\\ServiceManager\\Proxy\\LazyServiceFactory\n,\nin the \nlazy_services\n key passed in the service manager configuration:\n\n\n[\n    // map of service names and their relative class names - this\n    // is required since the service manager cannot know the\n    // class name of defined services up front\n    'class_map' =\n [\n        // 'foo' =\n 'MyApplication\\Foo',\n    ],\n\n    // directory where proxy classes will be written - default to system_get_tmp_dir()\n    'proxies_target_dir' =\n null,\n\n    // namespace of the generated proxies, default to \nProxyManagerGeneratedProxy\n\n    'proxies_namespace' =\n null,\n\n    // whether the generated proxy classes should be written to disk or generated on-the-fly\n    'write_proxy_files' =\n false,\n];\n\n\n\n\nAfter you have an instance, you can map lazy service/class pairs using\n\nmapLazyService()\n:\n\n\n$container-\nmapLazyService('foo', \\MyApplication\\Foo::class);",
            "title": "Lazy services"
        },
        {
            "location": "/lazy-services/#lazy-services",
            "text": "Zend\\ServiceManager  can use  delegator factories  to generate\n\"lazy\" references to your services.  Lazy services are  proxies  that\nget lazily instantiated, and keep a reference to the real instance of\nthe proxied service.",
            "title": "Lazy Services"
        },
        {
            "location": "/lazy-services/#use-cases",
            "text": "You may want to lazily initialize a service when it is instantiated very often,\nbut not always used.  A typical example is a database connection: it is a dependency to many other\nelements in your application, but that doesn't mean that every request will\nexecute queries through it.  Additionally, instantiating a connection to the database may require some time\nand eat up resources.  Proxying the database connection would allow to delay that overhead until the\nobject is really needed.",
            "title": "Use cases"
        },
        {
            "location": "/lazy-services/#setup",
            "text": "Zend\\ServiceManager\\Proxy\\LazyServiceFactory  is a  delegator factory \ncapable of generating lazy loading proxies for your services.  The lazy service facilities depend on  ProxyManager ;\nyou will need to install that package before using the feature:  $ composer require ocramius/proxy-manager",
            "title": "Setup"
        },
        {
            "location": "/lazy-services/#practical-example",
            "text": "To demonstrate how a lazy service works, you may use the following  Buzzer \nexample class, which is designed to be slow at instantiation time for\ndemonstration purposes:  namespace MyApp;\n\nclass Buzzer\n{\n    public function __construct()\n    {\n        // deliberately halting the application for 5 seconds\n        sleep(5);\n    }\n\n    public function buzz()\n    {\n        return 'Buzz!';\n    }\n}  You can then proceed and configure the service manager to generate proxies\ninstead of real services:  use MyApp\\Buzzer;\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\nuse Zend\\ServiceManager\\Proxy\\LazyServiceFactory;\nuse Zend\\ServiceManager\\ServiceManager;\n\n$serviceManager = new \\Zend\\ServiceManager\\ServiceManager([\n    'factories' =  [\n        Buzzer::class             =  InvokableFactory::class,\n    ],\n    'lazy_services' =  [\n         // Mapping services to their class names is required\n         // since the ServiceManager is not a declarative DIC.\n         'class_map' =  [\n             Buzzer::class =  Buzzer::class,\n         ],\n    ],\n    'delegators' =  [\n        Buzzer::class =  [\n            LazyServiceFactory::class,\n        ],\n    ],\n]);  This configuration tells the service manager to add the add LazyServiceFactory  as a delegator for  Buzzer .  You can now retrieve the buzzer:  use MyApp\\Buzzer;\n\n$buzzer = $serviceManager- get(Buzzer::class);\necho $buzzer- buzz();  To verify that the proxying occurred correctly, you can run the following code,\nwhich should delay the 5 seconds wait time hardcoded in  Buzzer::__construct \nuntil  Buzzer::buzz  is invoked:  use MyApp\\Buzzer;\n\nfor ($i = 0; $i   100; $i += 1) {\n    $buzzer = $serviceManager- get(Buzzer::class);\n    echo  created buzzer $i\\n ;\n}\n\necho $buzzer- buzz();",
            "title": "Practical example"
        },
        {
            "location": "/lazy-services/#configuration",
            "text": "This is the config structure expected by  Zend\\ServiceManager\\Proxy\\LazyServiceFactory ,\nin the  lazy_services  key passed in the service manager configuration:  [\n    // map of service names and their relative class names - this\n    // is required since the service manager cannot know the\n    // class name of defined services up front\n    'class_map' =  [\n        // 'foo' =  'MyApplication\\Foo',\n    ],\n\n    // directory where proxy classes will be written - default to system_get_tmp_dir()\n    'proxies_target_dir' =  null,\n\n    // namespace of the generated proxies, default to  ProxyManagerGeneratedProxy \n    'proxies_namespace' =  null,\n\n    // whether the generated proxy classes should be written to disk or generated on-the-fly\n    'write_proxy_files' =  false,\n];  After you have an instance, you can map lazy service/class pairs using mapLazyService() :  $container- mapLazyService('foo', \\MyApplication\\Foo::class);",
            "title": "Configuration"
        },
        {
            "location": "/plugin-managers/",
            "text": "Plugin managers\n\n\nPlugin managers are \nspecialized\n service managers, typically used to create\nhomogeneous objects of a specific type.\n\n\nBecause a plugin manager extends a service manager, it works the same and can\nbe configured similarly. It provides a separation of concerns (it will be used\nin specific contexts), and provides additional instance validation.\n\n\nZend Framework components extensively use plugin managers to create services\nthat share common functionalities. For instance, all validator services are\nspecified inside a specialized \nValidatorPluginManager\n.\n\n\nCreating a plugin manager\n\n\nTo create a plugin manager, you first need to create a new class that extends\n\nZend\\ServiceManager\\AbstractPluginManager\n:\n\n\nclass ValidatorPluginManager extends AbstractPluginManager\n{\n    protected $instanceOf = ValidatorInterface::class;\n}\n\n\n\n\nThe \n$instanceOf\n variable specifies a class/interface type that all instances\nretrieved from the plugin manager must fulfill. If an instance created by the\nplugin manager does not match, a \nZend\\ServiceManager\\Exception\\InvalidServiceException\n\nexception will be thrown.\n\n\nMost of the time, this shortcut is enough. However if you have more complex\nvalidation rules, you can override the \nvalidate()\n method:\n\n\nclass ValidatorPluginManager extends AbstractPluginManager\n{\n    public function validate($instance)\n    {\n        if ($instance instanceof Foo || $instance instanceof Bar) {\n            return;\n        }\n\n        throw new InvalidServiceException('This is not a valid service!');\n    }\n}\n\n\n\n\nConfiguring a plugin manager\n\n\nA plugin manager requires that you pass a parent service manager (typically,\nthe application's service manager) as well as service configuration. Service\nconfiguration follows the exact same pattern as for a normal service manager;\nrefer to the \nconfiguring the service manager\n section for details.\n\n\nBecause a plugin manager is often a service itself, we recommend you to\nregister the plugin manager as part of the general service manager, as shown\nbelow:\n\n\n$serviceManager = new ServiceManager([\n    'factories' =\n [\n        ValidatorPluginManager::class =\n function(ContainerInterface $container, $requestedName) {\n            return new ValidatorPluginManager($container, [\n                'factories' =\n [\n                    StringLengthValidator::class =\n InvokableFactory::class,\n                ],\n            ]);\n        },\n    ],\n]);\n\n// Get the plugin manager:\n\n$pluginManager = $serviceManager-\nget(ValidatorPluginManager::class);\n\n// Use the plugin manager\n\n$validator = $pluginManager-\nget(StringLengthValidator::class);\n\n\n\n\n\n\nUnlike the version 2 implementation, when inside the context of the factory\nof a service created by a plugin manager, the passed container \nwill not\nbe\n the plugin manager, but the parent service manager instead. If you need\naccess to other plugins of the same type, you will need to fetch the plugin\nmanager from the container:\n\n\nfunction ($container, $name, array $options = []) {\n    $validators = $container-\nget(ValidatorPluginManager::class);\n    // ...\n}",
            "title": "Plugin managers"
        },
        {
            "location": "/plugin-managers/#plugin-managers",
            "text": "Plugin managers are  specialized  service managers, typically used to create\nhomogeneous objects of a specific type.  Because a plugin manager extends a service manager, it works the same and can\nbe configured similarly. It provides a separation of concerns (it will be used\nin specific contexts), and provides additional instance validation.  Zend Framework components extensively use plugin managers to create services\nthat share common functionalities. For instance, all validator services are\nspecified inside a specialized  ValidatorPluginManager .",
            "title": "Plugin managers"
        },
        {
            "location": "/plugin-managers/#creating-a-plugin-manager",
            "text": "To create a plugin manager, you first need to create a new class that extends Zend\\ServiceManager\\AbstractPluginManager :  class ValidatorPluginManager extends AbstractPluginManager\n{\n    protected $instanceOf = ValidatorInterface::class;\n}  The  $instanceOf  variable specifies a class/interface type that all instances\nretrieved from the plugin manager must fulfill. If an instance created by the\nplugin manager does not match, a  Zend\\ServiceManager\\Exception\\InvalidServiceException \nexception will be thrown.  Most of the time, this shortcut is enough. However if you have more complex\nvalidation rules, you can override the  validate()  method:  class ValidatorPluginManager extends AbstractPluginManager\n{\n    public function validate($instance)\n    {\n        if ($instance instanceof Foo || $instance instanceof Bar) {\n            return;\n        }\n\n        throw new InvalidServiceException('This is not a valid service!');\n    }\n}",
            "title": "Creating a plugin manager"
        },
        {
            "location": "/plugin-managers/#configuring-a-plugin-manager",
            "text": "A plugin manager requires that you pass a parent service manager (typically,\nthe application's service manager) as well as service configuration. Service\nconfiguration follows the exact same pattern as for a normal service manager;\nrefer to the  configuring the service manager  section for details.  Because a plugin manager is often a service itself, we recommend you to\nregister the plugin manager as part of the general service manager, as shown\nbelow:  $serviceManager = new ServiceManager([\n    'factories' =  [\n        ValidatorPluginManager::class =  function(ContainerInterface $container, $requestedName) {\n            return new ValidatorPluginManager($container, [\n                'factories' =  [\n                    StringLengthValidator::class =  InvokableFactory::class,\n                ],\n            ]);\n        },\n    ],\n]);\n\n// Get the plugin manager:\n\n$pluginManager = $serviceManager- get(ValidatorPluginManager::class);\n\n// Use the plugin manager\n\n$validator = $pluginManager- get(StringLengthValidator::class);   Unlike the version 2 implementation, when inside the context of the factory\nof a service created by a plugin manager, the passed container  will not\nbe  the plugin manager, but the parent service manager instead. If you need\naccess to other plugins of the same type, you will need to fetch the plugin\nmanager from the container:  function ($container, $name, array $options = []) {\n    $validators = $container- get(ValidatorPluginManager::class);\n    // ...\n}",
            "title": "Configuring a plugin manager"
        },
        {
            "location": "/migration/",
            "text": "Migration Guide\n\n\nThe Service Manager was first introduced for Zend Framework 2.0.0. Its API\nremained the same throughout that version.\n\n\nVersion 3 is the first new major release of the Service Manager, and contains a\nnumber of backwards compatibility breaks. These were introduced to provide\nbetter performance and stability.\n\n\nCase Sensitivity and Normalization\n\n\nv2 normalized service names as follows:\n\n\n\n\nIt stripped non alphanumeric characters.\n\n\nIt lowercased the resulting string.\n\n\n\n\nThis was done to help prevent typographical errors from creating configuration\nerrors. However, it also presented a large performance hit, and led to some\nunexpected behaviors.\n\n\nIn v3, service names are case sensitive, and are not normalized in any way.\n\n\nAs such, you \nmust\n refer to services using the same case in which they were\nregistered.\n\n\nConfiguration\n\n\nA number of changes have been made to configuration of service and plugin\nmanagers:\n\n\n\n\nMinor changes in configuration arrays may impact your usage.\n\n\nConfigInterface\n implementations and consumers will need updating.\n\n\n\n\nConfiguration arrays\n\n\nConfiguration for v2 consisted of the following:\n\n\n[\n    'services' =\n [\n        // service name =\n instance pairs\n    ],\n    'aliases' =\n [\n        // alias =\n service name pairs\n    ],\n    'invokables' =\n [\n        // service name =\n class name pairs\n    ],\n    'factories' =\n [\n        // service name =\n factory pairs\n    ],\n    'abstract_factories' =\n [\n        // abstract factories\n    ],\n    'initializers' =\n [\n        // initializers\n    ],\n    'delegators' =\n [\n        // service name =\n [ delegator factories ]\n    ],\n    'shared' =\n [\n        // service name =\n boolean\n    ],\n    'share_by_default' =\n boolean,\n]\n\n\n\n\nIn v3, the configuration remains the same, with the following additions:\n\n\n[\n    'lazy_services' =\n [\n        // The class_map is required if using lazy services:\n        'class_map' =\n [\n            // service name =\n class name pairs\n        ],\n        // The following are optional:\n        'proxies_namespace'  =\n 'Alternate namespace to use for generated proxy classes',\n        'proxies_target_dir' =\n 'path in which to write generated proxy classes',\n        'write_proxy_files'  =\n true, // boolean; false by default\n    ],\n]\n\n\n\n\nThe main change is the addition of integrated lazy service configuration is now\nintegrated.\n\n\nConfigInterface\n\n\nThe principal change to the \nConfigInterface\n is the addition of the\n\ntoArray()\n method. This method is intended to return a configuration array in\nthe format listed above, for passing to either the constructor or the\n\nconfigure()\n method of the \nServiceManager\n..\n\n\nConfig class\n\n\nZend\\ServiceManager\\Config\n has been updated to follow the changes to the\n\nConfigInterface\n and \nServiceManager\n. This essentially means that it removes\nthe various getter methods, and adds the \ntoArray()\n method.\n\n\nInvokables\n\n\nInvokables no longer exist,\n at least, not identically to how they existed in\nZF2.\n\n\nInternally, \nServiceManager\n now does the following for \ninvokables\n entries:\n\n\n\n\nIf the name and value match, it creates a \nfactories\n entry mapping the\n  service name to \nZend\\ServiceManager\\Factory\\InvokableFactory\n.\n\n\nIf the name and value \ndo not\n match, it creates an \naliases\n entry mapping the\n  service name to the class name, \nand\n a \nfactories\n entry mapping the class\n  name to \nZend\\ServiceManager\\Factory\\InvokableFactory\n.\n\n\n\n\nThis means that you can use your existing \ninvokables\n configuration from\nversion 2 in version 3. However, we recommend starting to update your\nconfiguration to remove \ninvokables\n entries in favor of factories (and aliases,\nif needed).\n\n\n\n\nInvokables and plugin managers\n\n\nIf you are creating a plugin manager and in-lining invokables into the class\ndefinition, you will need to make some changes.\n\n\n$invokableClasses\n will need to become \n$factories\n entries, and you will\npotentially need to add \n$aliases\n entries.\n\n\nAs an example, consider the following, from zend-math v2.x:\n\n\nclass AdapterPluginManager extends AbstractPluginManager\n{\n    protected $invokableClasses = [\n        'bcmath' =\n Adapter\\Bcmath::class,\n        'gmp'    =\n Adapter\\Gmp::class,\n    ];\n}\n\n\n\n\nBecause we no longer define an \n$invokableClasses\n property, for v3.x, this\nnow becomes:\n\n\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nclass AdapterPluginManager extends AbstractPluginManager\n{\n    protected $aliases = [\n        'bcmath' =\n Adapter\\Bcmath::class,\n        'gmp'    =\n Adapter\\Gmp::class,\n    ];\n\n    protected $factories = [\n        Adapter\\BcMath::class =\n InvokableFactory::class,\n        Adapter\\Gmp::class    =\n InvokableFactory::class,\n    ];\n}\n\n\n\n\n\n\nLazy Services\n\n\nIn v2, if you wanted to create a lazy service, you needed to take the following\nsteps:\n\n\n\n\nEnsure you have a \nconfig\n service, with a \nlazy_services\n key that contained\n  the configuration necessary for the \nLazyServiceFactory\n.\n\n\nAssign the \nLazyServiceFactoryFactory\n as a factory for the\n  \nLazyServiceFactory\n\n\nAssign the \nLazyServiceFactory\n as a delegator factory for your service.\n\n\n\n\nAs an example:\n\n\nuse Zend\\ServiceManager\\Proxy\\LazyServiceFactoryFactory;\n\n$config = [\n    'lazy_services' =\n [\n        'class_map' =\n [\n            'MyClass' =\n 'MyClass',\n        ],\n        'proxies_namespace'  =\n 'TestAssetProxy',\n        'proxies_target_dir' =\n 'data/proxies/',\n        'write_proxy_files'  =\n true,\n    ],\n];\n\nreturn [\n    'services' =\n [\n        'config' =\n $config,\n    ],\n    'invokables' =\n [\n        'MyClass' =\n 'MyClass',\n    ],\n    'factories' =\n [\n        'LazyServiceFactory' =\n LazyServiceFactoryFactory::class,\n    ],\n    'delegators' =\n [\n        'MyClass' =\n [\n            'LazyServiceFactory',\n        ],\n    ],\n];\n\n\n\n\nThis was done in part because lazy services were introduced later in the v2\ncycle, and not fully integrated in order to retain the API.\n\n\nIn order to reduce the number of dependencies and steps necessary to configure\nlazy services, the following changes were made for v3:\n\n\n\n\nLazy service configuration can now be passed directly to the service manager;\n  it is no longer dependent on a \nconfig\n service.\n\n\nThe ServiceManager itself is now responsible for creating the\n  \nLazyServiceFactory\n delegator factory, based on the configuration present.\n\n\n\n\nThe above example becomes the following in v3:\n\n\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\nuse Zend\\ServiceManager\\Proxy\\LazyServiceFactory;\n\nreturn [\n    'factories' =\n [\n        'MyClass' =\n InvokableFactory::class,\n    ],\n    'delegators' =\n [\n        'MyClass' =\n [\n            LazyServiceFactory::class,\n        ],\n    ],\n    'lazy_services' =\n [\n        'class_map' =\n [\n            'MyClass' =\n 'MyClass',\n        ],\n        'proxies_namespace'  =\n 'TestAssetProxy',\n        'proxies_target_dir' =\n 'data/proxies/',\n        'write_proxy_files'  =\n true,\n    ],\n];\n\n\n\n\nAdditionally, assuming you have configured lazy services initially with the\nproxy namespace, target directory, etc., you can map lazy services using the new\nmethod \nmapLazyService($name, $class)\n:\n\n\n$container-\nmapLazyService('MyClass', 'MyClass');\n// or, more simply:\n$container-\nmapLazyService('MyClass');\n\n\n\n\nServiceLocatorInterface Changes\n\n\nThe \nServiceLocatorInterface\n now extends the\n\ncontainer-interop\n\ninterface \nContainerInterface\n, which defines the same \nget()\n and \nhas()\n\nmethods as were previously defined.\n\n\nAdditionally, it adds a new method:\n\n\npublic function build($name, array $options = null)\n\n\n\n\nThis method is defined to \nalways\n return a \nnew\n instance of the requested\nservice, and to allow using the provided \n$options\n when creating the instance.\n\n\nServiceManager API Changes\n\n\nZend\\ServiceManager\\ServiceManager\n remains the primary interface with which\ndevelopers will interact. It has the following changes in v3:\n\n\n\n\nIt adds a new method, \nconfigure()\n, which allows configuring all instance\n  generation capabilities (aliases, factories, abstract factories, etc.) at\n  once.\n\n\nPeering capabilities were removed.\n\n\nExceptions are \nalways\n thrown when service instance creation fails or\n  produces an error; you can no longer disable this.\n\n\nConfiguration no longer requires a \nZend\\ServiceManager\\Config\n instance.\n  \nConfig\n can be used, but is no needed.\n\n\nIt adds a new method, \nbuild()\n, for creating discrete service instances.\n\n\n\n\nMethods Removed\n\n\nThe following methods are removed\n in v3:\n\n\n\n\nsetShareByDefault()\n/\nshareByDefault()\n; this can be passed during\n  instantiation or via \nconfigure()\n.\n\n\nsetThrowExceptionInCreate()\n/\ngetThrowExceptionInCreate()\n; exceptions are\n  \nalways\n thrown when errors are encountered during service instance creation.\n\n\nsetRetrieveFromPeeringManagerFirst()\n/\nretrieveFromPeeringManagerFirst()\n;\n  peering is no longer supported.\n\n\n\n\nConstructor\n\n\nThe constructor now accepts an array of service configuration, not a\n\nZend\\ServiceManager\\Config\n instance.\n\n\nUse \nbuild()\n for discrete instances\n\n\nThe new method \nbuild()\n acts as a factory method for configured services, and\nwill \nalways\n return a new instance, never a shared one.\n\n\nAdditionally, it provides factory capabilities; you may pass an additional,\noptional argument, \n$options\n, which should be an array of additional options a\nfactory may use to create a new instance. This is primarily of interest when\ncreating plugin managers (more on plugin managers below), which may pass that\ninformation on in order to create discrete plugin instances with specific state.\n\n\nAs examples:\n\n\nuse Zend\\Validator\\Between;\n\n$between = $container-\nbuild(Between::class, [\n    'min'        =\n 5,\n    'max'        =\n 10,\n    'inclusive' =\n true,\n]);\n\n$alsoBetween = $container-\nbuild(Between::class, [\n    'min'       =\n 0,\n    'max'       =\n 100,\n    'inclusive' =\n false,\n]);\n\n\n\n\nThe above two validators would be different instances, with their own\nconfiguration.\n\n\nFactories\n\n\nInternally, the \nServiceManager\n now only uses the new factory interfaces\ndefined in the \nZend\\ServiceManager\\Factory\n namespace. These \nreplace\n the\ninterfaces defined in version 2, and define completely new signatures.\n\n\nFor migration purposes, all original interfaces were retained, and now inherit\nfrom the new interfaces. This provides a migration path; you can add the methods\ndefined in the new interfaces to your existing factories targeting v2, and\nsafely upgrade. (Typically, you will then have the version 2 methods proxy to\nthose defined in version 3.)\n\n\nInterfaces and relations to version 2\n\n\n\n\n\n\n\n\nVersion 2 Interface\n\n\nVersion 3 Interface\n\n\n\n\n\n\n\n\n\n\nZend\\ServiceManager\\AbstractFactoryInterface\n\n\nZend\\ServiceManager\\Factory\\AbstractFactoryInterface\n\n\n\n\n\n\nZend\\ServiceManager\\DelegatorFactoryInterface\n\n\nZend\\ServiceManager\\Factory\\DelegatorFactoryInterface\n\n\n\n\n\n\nZend\\ServiceManager\\FactoryInterface\n\n\nZend\\ServiceManager\\Factory\\FactoryInterface\n\n\n\n\n\n\n\n\nThe version 2 interfaces now extend those in version 3, but are marked\n\ndeprecated\n. You can continue to use them, but will be required to update\nyour code to use the new interfaces in the future.\n\n\nAbstractFactoryInterface\n\n\nThe previous signature of the \nAbstractFactoryInterface\n was:\n\n\ninterface AbstractFactoryInterface\n{\n    /**\n     * Determine if we can create a service with name\n     *\n     * @param ServiceLocatorInterface $serviceLocator\n     * @param $name\n     * @param $requestedName\n     * @return bool\n     */\n    public function canCreateServiceWithName(ServiceLocatorInterface $serviceLocator, $name, $requestedName);\n\n    /**\n     * Create service with name\n     *\n     * @param ServiceLocatorInterface $serviceLocator\n     * @param $name\n     * @param $requestedName\n     * @return mixed\n     */\n    public function createServiceWithName(ServiceLocatorInterface $serviceLocator, $name, $requestedName);\n}\n\n\n\n\nThe new signature is:\n\n\ninterface AbstractFactoryInterface extends FactoryInterface\n{\n    /**\n     * Does the factory have a way to create an instance for the service?\n     *\n     * @param  ContainerInterface $container\n     * @param  string $requestedName\n     * @return bool\n     */\n    public function canCreate(ContainerInterface $container, $requestedName);\n}\n\n\n\n\nNote that it now \nextends\n the \nFactoryInterface\n (detailed below), and thus the\nfactory logic has the same signature.\n\n\nIn v2, the abstract factory defined the method \ncanCreateServiceWithName()\n; in\nv3, this is renamed to \ncanCreate()\n, and the method also now receives only two\narguments, the container and the requested service name.\n\n\nTo prepare your version 2 implementation to work upon upgrade to version 3:\n\n\n\n\nAdd the methods \ncanCreate()\n and \n__invoke()\n as defined in version 3.\n\n\nModify your existing \ncanCreateServiceWithName()\n method to proxy to\n  \ncanCreate()\n\n\nModify your existing \ncreateServiceWithName()\n method to proxy to\n  \n__invoke()\n\n\n\n\nAs an example, given the following implementation from version 2:\n\n\nuse Zend\\ServiceManager\\AbstractFactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\n\nclass LenientAbstractFactory implements AbstractFactoryInterface\n{\n    public function canCreateServiceWithName(ServiceLocatorInterface $services, $name, $requestedName)\n    {\n        return class_exists($requestedName);\n    }\n\n    public function createServiceWithName(ServiceLocatorInterface $services, $name, $requestedName)\n    {\n        return new $requestedName();\n    }\n}\n\n\n\n\nTo update this for version 3 compatibility, you will add the methods\n\ncanCreate()\n and \n__invoke()\n, move the code from the existing methods into\nthem, and update the existing methods to proxy to the new methods:\n\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\AbstractFactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\n\nclass LenientAbstractFactory implements AbstractFactoryInterface\n{\n    public function canCreate(ContainerInterface $container, $requestedName)\n    {\n        return class_exists($requestedName);\n    }\n\n    public function canCreateServiceWithName(ServiceLocatorInterface $services, $name, $requestedName)\n    {\n        return $this-\ncanCreate($services, $requestedName);\n    }\n\n    public function __invoke(ContainerInterface $container, $requestedName, array $options = null)\n    {\n        return new $requestedName();\n    }\n\n    public function createServiceWithName(ServiceLocatorInterface $services, $name, $requestedName)\n    {\n        return $this($services, $requestedName);\n    }\n}\n\n\n\n\nAfter you have upgraded to version 3, you can take the following steps to remove\nthe migration artifacts:\n\n\n\n\nUpdate your class to implement the new interface.\n\n\nRemove the \ncanCreateServiceWithName()\n and \ncreateServiceWithName()\n methods\n  from your implementation.\n\n\n\n\nFrom our example above, we would update the class to read as follows:\n\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Factory\\AbstractFactoryInterface; // \n-- note the change!\n\nclass LenientAbstractFactory implements AbstractFactoryInterface\n{\n    public function canCreate(ContainerInterface $container, $requestedName)\n    {\n        return class_exists($requestedName);\n    }\n\n    public function __invoke(ContainerInterface $container, $requestedName, array $options = null)\n    {\n        return new $requestedName();\n    }\n}\n\n\n\n\nDelegatorFactoryInterface\n\n\nThe previous signature of the \nDelegatorFactoryInterface\n was:\n\n\ninterface DelegatorFactoryInterface\n{\n    /**\n     * A factory that creates delegates of a given service\n     *\n     * @param ServiceLocatorInterface $serviceLocator the service locator which requested the service\n     * @param string                  $name           the normalized service name\n     * @param string                  $requestedName  the requested service name\n     * @param callable                $callback       the callback that is responsible for creating the service\n     *\n     * @return mixed\n     */\n    public function createDelegatorWithName(ServiceLocatorInterface $serviceLocator, $name, $requestedName, $callback);\n}\n\n\n\n\nThe new signature is:\n\n\ninterface DelegatorFactoryInterface\n{\n    /**\n     * A factory that creates delegates of a given service\n     *\n     * @param  ContainerInterface $container\n     * @param  string             $name\n     * @param  callable           $callback\n     * @param  null|array         $options\n     * @return object\n     */\n    public function __invoke(ContainerInterface $container, $name, callable $callback, array $options = null);\n}\n\n\n\n\nNote that the \n$name\n and \n$requestedName\n arguments are now merged into a\nsingle \n$name\n argument, and that the factory now allows passing additional\noptions to use (typically as passed via \nbuild()\n).\n\n\nTo prepare your existing delegator factories for version 3, take the following\nsteps:\n\n\n\n\nImplement the \n__invoke()\n method in your existing factory, copying the code\n  from your existing \ncreateDelegatorWithName()\n method into it.\n\n\nModify the \ncreateDelegatorWithName()\n method to proxy to the new method.\n\n\n\n\nConsider the following delegator factory that works for version 2:\n\n\nuse Zend\\ServiceManager\\DelegatorFactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\n\nclass ObserverAttachmentDelegator implements DelegatorFactoryInterface\n{\n    public function createDelegatorWithName(ServiceLocatorInterface $serviceLocator, $name, $requestedName, $callback)\n    {\n        $subject = $callback();\n        $subject-\nattach($serviceLocator-\nget(Observer::class);\n        return $subject;\n    }\n}\n\n\n\n\nTo prepare this for version 3, we'd implement the \n__invoke()\n signature from\nversion 3, and modify \ncreateDelegatorWithName()\n to proxy to it:\n\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\DelegatorFactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\n\nclass ObserverAttachmentDelegator implements DelegatorFactoryInterface\n{\n    public function __invoke(ContainerInterface $container, $requestedName, callable $callback, array $options = null)\n    {\n        $subject = $callback();\n        $subject-\nattach($container-\nget(Observer::class);\n        return $subject;\n    }\n\n    public function createDelegatorWithName(ServiceLocatorInterface $serviceLocator, $name, $requestedName, $callback)\n    {\n        return $this($serviceLocator, $requestedName, $callback);\n    }\n}\n\n\n\n\nAfter you have upgraded to version 3, you can take the following steps to remove\nthe migration artifacts:\n\n\n\n\nUpdate your class to implement the new interface.\n\n\nRemove the \ncreateDelegatorWithName()\n method from your implementation.\n\n\n\n\nFrom our example above, we would update the class to read as follows:\n\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Factory\\DelegatorFactoryInterface; // \n-- note the change!\n\nclass ObserverAttachmentDelegator implements DelegatorFactoryInterface\n{\n    public function __invoke(ContainerInterface $container, $requestedName, callable $callback, array $options = null)\n    {\n        $subject = $callback();\n        $subject-\nattach($container-\nget(Observer::class);\n        return $subject;\n    }\n}\n\n\n\n\nFactoryInterface\n\n\nThe previous signature of the \nFactoryInterface\n was:\n\n\ninterface FactoryInterface\n{\n    /**\n     * Create service\n     *\n     * @param ServiceLocatorInterface $serviceLocator\n     * @return mixed\n     */\n    public function createService(ServiceLocatorInterface $serviceLocator);\n}\n\n\n\n\nThe new signature is:\n\n\ninterface FactoryInterface\n{\n    /**\n     * Create an object\n     *\n     * @param  ContainerInterface $container\n     * @param  string             $requestedName\n     * @param  null|array         $options\n     * @return object\n     */\n    public function __invoke(ContainerInterface $container, $requestedName, array $options = null);\n}\n\n\n\n\nNote that the factory now accepts an additional \nrequired\n argument,\n\n$requestedName\n; v2 already passed this argument, but it was not specified in\nthe interface itself. Additionally, a third \noptional\n argument, \n$options\n,\nallows you to provide \n$options\n to the \nServiceManager::build()\n method;\nfactories can then take these into account when creating an instance.\n\n\nBecause factories now can expect to receive the service name, they may be\nre-used for multiple services, largely replacing abstract factories in version\n3.\n\n\nTo prepare your existing factories for version 3, take the following steps:\n\n\n\n\nImplement the \n__invoke()\n method in your existing factory, copying the code\n  from your existing \ncreateService()\n method into it.\n\n\nModify the \ncreateService()\n method to proxy to the new method.\n\n\n\n\nConsider the following factory that works for version 2:\n\n\nuse Zend\\ServiceManager\\FactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\n\nclass FooFactory implements FactoryInterface\n{\n    public function createService(ServiceLocatorInterface $services)\n    {\n        return new Foo($services-\nget(Bar::class));\n    }\n}\n\n\n\n\nTo prepare this for version 3, we'd implement the \n__invoke()\n signature from\nversion 3, and modify \ncreateService()\n to proxy to it:\n\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\FactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\n\nclass FooFactory implements FactoryInterface\n{\n    public function __invoke(ContainerInterface $container, $requestedName, array $options = null)\n    {\n        return new Foo($container-\nget(Bar::class));\n    }\n\n    public function createService(ServiceLocatorInterface $services)\n    {\n        return $this($services, Foo::class);\n    }\n}\n\n\n\n\nNote that the call to \n$this()\n adds a new argument; since your factory isn't\nusing the \n$requestedName\n, this can be anything, but must be passed to prevent\na fatal exception due to a missing argument. In this case, we chose to pass the\nname of the class the factory is creating.\n\n\nAfter you have upgraded to version 3, you can take the following steps to remove\nthe migration artifacts:\n\n\n\n\nUpdate your class to implement the new interface.\n\n\nRemove the \ncreateService()\n method from your implementation.\n\n\n\n\nFrom our example above, we would update the class to read as follows:\n\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Factory\\FactoryInterface; // \n-- note the change!\n\nclass FooFactory implements FactoryInterface\n{\n    public function __invoke(ContainerInterface $container, $requestedName, array $options = null)\n    {\n        return new Foo($container-\nget(Bar::class));\n    }\n}\n\n\n\n\n\n\nMany factories already work with v3!\n\n\nWithin the skeleton application, tutorial, and even in commonly shipped\nmodules such as those in Apigility, we have typically suggested building your\nfactories as invokable classes. If you were doing this already, your factories\nwill already work with version 3!\n\n\nVersion 2 factories can accept the requested name already\n\n\nSince 2.2, factories have been passed two additional parameters, the\n\"canonical\" name (a mis-nomer, as it is actually the normalized name), and the\n\"requested\" name (the actual string passed to \nget()\n). As such, you can\nalready write factories that accept the requested name, and have them\nchange behavior based on that information!\n\n\n\n\nNew InvokableFactory Class\n\n\nZend\\ServiceManager\\Factory\\InvokableFactory\n is a new \nFactoryInterface\n\nimplementation that provides the capabilities of the \"invokable classes\" present\nin version 2. It essentially instantiates and returns the requested class name;\nif \n$options\n is non-empty, it passes them directly to the constructor.\n\n\nThis class was \nadded to the version 2 tree\n\nto allow developers to start using it when preparing their code for version 3.\nThis is particularly of interest when creating plugin managers, as you'll\ntypically want the internal configuration to only include factories and aliases.\n\n\nInitializers\n\n\nInitializers are still present in the Service Manager component, but exist\nprimarily for backwards compatibility; we recommend using delegator factories\nfor setter and interface injection instead of initializers, as those will be run\nper-service, versus for all services.\n\n\nFor migration purposes, the original interface was retained, and now inherits\nfrom the new interface. This provides a migration path; you can add the method\ndefined in the new interface to your existing initializers targeting v2, and\nsafely upgrade. (Typically, you will then have the version 2 method proxy to\nthe one defined in version 3.)\n\n\nThe following changes were made to initializers:\n\n\n\n\nZend\\ServiceManager\\InitializerInterface\n was renamed to\n  \nZend\\ServiceManager\\Initializer\\InitializerInterface\n.\n\n\nThe interface itself has a new signature.\n\n\n\n\nThe previous signature was:\n\n\npublic function initialize($instance, ServiceLocatorInterface $serviceLocator)\n\n\n\n\nIt is now:\n\n\npublic function __invoke(ContainerInterface $container, $instance)\n\n\n\n\nThe changes were made to ensure the signature is internally consistent with the\nvarious factories.\n\n\nTo prepare your existing initializers for version 3, take the following steps:\n\n\n\n\nImplement the \n__invoke()\n method in your existing factory, copying the code\n  from your existing \ninitialize()\n method into it.\n\n\nModify the \ninitialize()\n method to proxy to the new method.\n\n\n\n\nAs an example, consider this initializer for version 2:\n\n\nuse Zend\\ServiceManager\\InitializerInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\n\nclass FooInitializer implements InitializerInterface\n{\n    public function initializer($instance, ServiceLocatorInterface $services)\n    {\n        if (! $instance implements FooAwareInterface) {\n            return $instance;\n        }\n        $instance-\nsetFoo($services-\nget(FooInterface::class);\n        return $instance;\n    }\n}\n\n\n\n\nTo prepare this for version 3, we'd implement the \n__invoke()\n signature from\nversion 3, and modify \ninitialize()\n to proxy to it:\n\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\InitializerInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\n\nclass FooInitializer implements InitializerInterface\n{\n    public function __invoke(ContainerInterface $container, $instance)\n    {\n        if (! $instance implements FooAwareInterface) {\n            return $instance;\n        }\n        $container-\nsetFoo($services-\nget(FooInterface::class);\n        return $instance;\n    }\n\n    public function initializer($instance, ServiceLocatorInterface $services)\n    {\n        return $this($services, $instance);\n    }\n}\n\n\n\n\nAfter you have upgraded to version 3, you can take the following steps to remove\nthe migration artifacts:\n\n\n\n\nUpdate your class to implement the new interface.\n\n\nRemove the \ninitialize()\n method from your implementation.\n\n\n\n\nFrom our example above, we would update the class to read as follows:\n\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Initializer\\InitializerInterface; // \n-- note the change!\n\nclass FooInitializer implements InitializerInterface\n{\n    public function __invoke(ContainerInterface $container, $instance)\n    {\n        if (! $instance implements FooAwareInterface) {\n            return $instance;\n        }\n        $container-\nsetFoo($services-\nget(FooInterface::class);\n        return $instance;\n    }\n}\n\n\n\n\n\n\nUpdate your callables!\n\n\nVersion 2 allows you to provide initializers as PHP callables. However, this\nmeans that the signature of those callables is incorrect for version 3!\n\n\nTo make your code forwards compatible, you have two paths:\n\n\nThe first is to simply provide an \nInitializerInterface\n implementation\ninstead. This guarantees that the correct method is called based on the\nversion of the \nServiceManager\n in use.\n\n\nThe second approach is to omit typehints on the arguments, and do typechecks\ninternally. As an example, let's say you have the following:\n\n\n$container-\naddInitializer(function ($instance, ContainerInterface $container) {\n     if (! $instance implements FooAwareInterface) {\n         return $instance;\n     }\n     $container-\nsetFoo($services-\nget(FooInterface::class);\n     return $instance;\n});\n\n\n\n\nTo make this future-proof, remove the typehints, and check the types within\nthe callable:\n\n\n$container-\naddInitializer(function ($first, $second) {\n     if ($first instanceof ContainerInterface) {\n         $container = $first;\n         $instance = $second;\n     } else {\n         $container = $second;\n         $instance = $first;\n     }\n     if (! $instance implements FooAwareInterface) {\n         return $instance;\n     }\n     $container-\nsetFoo($services-\nget(FooInterface::class);\n     return $instance;\n});\n\n\n\n\nThis approach can also be done if you omitted typehints in the first place.\nRegardless, the important part to remember is that order of arguments is\ninverted between the two versions.\n\n\n\n\nPlugin Managers\n\n\nIn version 2, plugin managers were \nServiceManager\n instances that implemented\nboth the \nMutableCreationOptionsInterface\n and \nServiceLocatorAwareInterface\n,\nand extended \nAbstractPluginManager\n.  Plugin managers passed themselves to\nfactories, abstract factories, etc., requiring pulling the parent service\nmanager, if composed, in order to resolve application-level dependencies.\n\n\nIn version 3, we define the following:\n\n\n\n\nZend\\ServiceManager\\PluginManagerInterface\n, which provides the public API\n  differences from the \nServiceLocatorInterface\n.\n\n\nZend\\ServiceManager\\AbstractPluginManager\n, which gives the basic\n  capabilities for plugin managers. The class now has a (semi) \nrequired\n\n  dependency on the application-level service manager instance, which is passed\n  to all factories, abstract factories, etc. (More on this below.)\n\n\n\n\nPluginManagerInterface\n\n\nZend\\ServiceManager\\PluginInterface\n is a new interface for version 3,\nextending \nServiceLocatorInterface\n and adding one method:\n\n\n/**\n * Validate an instance\n *\n * @param  object $instance\n * @return void\n * @throws InvalidServiceException If created instance does not respect the\n *     constraint on type imposed by the plugin manager\n */\npublic function validate($instance);\n\n\n\n\nAll plugin managers \nmust\n implement this interface. For backwards-compatibility\npurposes, \nAbstractPluginManager\n will check for the \nvalidatePlugin()\n method\n(defined as abstract in v2), and, on discovery, trigger an \nE_USER_DEPRECATED\n\nnotice, followed by invocation of that method.\n\n\nAbstractPluginManager\n\n\nAs it did in version 2, \nAbstractPluginManager\n extends \nServiceManager\n. \nThat\nmeans that all changes made to the \nServiceManager\n for v3 also apply to the\n\nAbstractPluginManager\n.\n\n\nIn addition, review the following changes.\n\n\nConstructor\n\n\n\n\nThe constructor now accepts the following arguments, in the following order:\n\n\nThe parent container instance; this is usually the application-level\n    \nServiceManager\n instance.\n\n\nOptionally, an array of configuration for the plugin manager instance; this\n    should have the same format as for a \nServiceManager\n instance.\n\n\nvalidatePlugin()\n was renamed to \nvalidate()\n (now defined in\n  \nPluginManagerInterface\n). The \nAbstractPluginManager\n provides\n  a basic implementation (detailed below).\n\n\nThe signature of \nget()\n changes (more below).\n\n\n\n\nFor backwards compatibility purposes, the constructor \nalso\n allows the\nfollowing for the initial argument:\n\n\n\n\nA \nnull\n value. In this case, the plugin manager will use itself as the\n  creation context, \nbut also raise a deprecation notice indicating a\n  container should be passed instead.\n You can pass the parent container\n  to the \nsetServiceLocator()\n method to reset the creation context, but,\n  again, this raises a deprecation notice.\n\n\nA \nConfigInterface\n instance. In this case, the plugin manager will call\n  the config instance's \ntoArray()\n method to cast it to an array, and use the\n  return value as the configuration to pass to the parent constructor. As with\n  the \nnull\n value, the plugin manager will be set as its own creation context.\n\n\n\n\nValidation\n\n\nThe \nvalidate()\n method is defined as follows:\n\n\npublic function validate($instance)\n{\n    if (method_exists($this, 'validatePlugin')) {\n        trigger_error(sprintf(\n            '%s::validatePlugin() has been deprecated as of 3.0; please define validate() instead',\n            get_class($this)\n        ), E_USER_DEPRECATED);\n        $this-\nvalidatePlugin($instance);\n        return;\n    }\n\n    if (empty($this-\ninstanceOf) || $instance instanceof $this-\ninstanceOf) {\n        return;\n    }\n\n    throw new InvalidServiceException(sprintf(\n        'Plugin manager \n%s\n expected an instance of type \n%s\n, but \n%s\n was received',\n        __CLASS__,\n        $this-\ninstanceOf,\n        is_object($instance) ? get_class($instance) : gettype($instance)\n    ));\n}\n\n\n\n\nThe two takeaways from this are:\n\n\n\n\nIf you are upgrading from v2, your code should continue to work, \nbut will\n  emit a deprecation notice\n. The way to remove the deprecation notice is to\n  rename the \nvalidatePlugin()\n method to \nvalidate()\n, or to remove it and\n  define the \n$instanceOf\n property (if all you're doing is checking the\n  plugin against a single typehint).\n\n\nMost plugin manager instances can simply define the \n$instanceOf\n property to\n  indicate what plugin interface is considered valid for the plugin manager, and\n  make no further changes to the abstract plugin manager:\n\n\n\n\nprotected $instanceOf = ValidatorInterface::class;\n\n\n\n\nget()\n\n\nThe \nget()\n signature changes from:\n\n\npublic function get($name, $options = [], $usePeeringServiceManagers = true)\n\n\n\n\nto:\n\n\npublic function get($name, array $options = null)\n\n\n\n\nEssentially: \n$options\n now \nmust\n be an array if passed, and peering is no\nlonger supported.\n\n\nDeprecated methods\n\n\nFinally, the following methods from v2's \nServiceLocatorAwareInterface\n are\nretained (without implementing the interface), but marked as deprecated:\n\n\n\n\nsetServiceLocator()\n. This method exists as many tests and plugin manager\n  factories were using it to inject the parent locator (now called the creation\n  context). This method may still be used, and will now set the creation context\n  for the plugin manager, but also emit a deprecation warning.\n\n\ngetServiceLocator()\n is implemented in \nServiceManager\n (from which\n  \nAbstractPluginManager\n inherits), but marked as deprecated.\n\n\n\n\nRegarding this latter point, \ngetServiceLocator()\n exists to provide backwards\ncompatibility \nfor existing plugin factories\n. These factories typically pull\ndependencies from the parent/application container in order to initialize the\nplugin. In v2, this would look like:\n\n\nfunction ($plugins)\n{\n    $services = $plugins-\ngetServiceLocator();\n\n    // pull dependencies from $services:\n    $foo = $services-\nget('Foo');\n    $bar = $services-\nget('Bar');\n\n    return new Plugin($foo, $bar);\n}\n\n\n\n\nIn v3, the initial argument to the factory is not the plugin manager instance,\nbut the \ncreation context\n, which is analogous to the parent locator in v2. In\norder to preserve existing behavior, we added the \ngetServiceLocator()\n method\nto the \nServiceManager\n. As such, the above will continue to work in v3.\n\n\nHowever, this method is marked as deprecated, and will emit an\n\nE_USER_DEPRECATED\n notice. To remove the notice, you will need to upgrade your\ncode. The above example thus becomes:\n\n\nfunction ($services)\n{\n    // pull dependencies from $services:\n    $foo = $services-\nget('Foo');\n    $bar = $services-\nget('Bar');\n\n    return new Plugin($foo, $bar);\n}\n\n\n\n\nIf you \nwere\n using the passed plugin manager and pulling other plugins, you\nwill need to update your code to retrieve the plugin manager from the passed\ncontainer. As an example, given this:\n\n\nfunction ($plugins)\n{\n    $anotherPlugin = $plugins-\nget('AnotherPlugin');\n    return new Plugin($anotherPlugin);\n}\n\n\n\n\nYou will need to rewrite it to:\n\n\nfunction ($services)\n{\n    $plugins = $services-\nget('PluginManager');\n    $anotherPlugin = $plugins-\nget('AnotherPlugin');\n    return new Plugin($anotherPlugin);\n}\n\n\n\n\nPlugin Service Creation\n\n\nThe \nget()\n method has new behavior:\n\n\n\n\nWhen non-empty \n$options\n are passed, it \nalways\n delegates to \nbuild()\n, and\n  thus will \nalways\n return a \nnew instance\n. If you are using \n$options\n, the\n  assumption is that you are using the plugin manager as a factory, and thus the\n  instance should not be cached.\n\n\nWithout \n$options\n, \nget()\n will cache by default (the default behavior of\n  \nServiceManager\n). To \nnever\n cache instances, either set the\n  \n$sharedByDefault\n class property to \nfalse\n, or pass a boolean \nfalse\n value\n  via the \nshared_by_default\n configuration key.\n\n\n\n\nMigration example\n\n\nLet's consider the following plugin manager geared towards version 2:\n\n\nuse RuntimeException;\nuse Zend\\ServiceManager\\AbstractPluginManager;\n\nclass ObserverPluginManager extends AbstractPluginManager\n{\n    protected $invokables = [\n        'mail' =\n MailObserver::class,\n        'log' =\n LogObserver::class,\n    ];\n\n    public function validatePlugin($instance)\n    {\n        if (! $plugin instanceof ObserverInterface) {\n            throw new RuntimeException(sprintf(\n                'Invalid plugin \n%s\n created; not an instance of %s',\n                get_class($instance),\n                ObserverInterface::class\n            ));\n        }\n    }\n}\n\n\n\n\nTo prepare this for version 3, we need to do the following:\n\n\n\n\nWe need to change the \n$invokables\n configuration to a combination of\n  \nfactories\n and \naliases\n.\n\n\nWe need to implement a \nvalidate()\n method.\n\n\nWe need to update the \nvalidatePlugin()\n method to proxy to \nvalidate()\n.\n\n\n\n\nDoing so, we get the following result:\n\n\nuse RuntimeException;\nuse Zend\\ServiceManager\\AbstractPluginManager;\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nclass ObserverPluginManager extends AbstractPluginManager\n{\n    protected $instanceOf = ObserverInterface::class;\n\n    protected $aliases = [\n        'mail' =\n MailObserver::class,\n        'Mail' =\n MailObserver::class,\n        'log' =\n LogObserver::class,\n        'Log' =\n LogObserver::class,\n    ];\n\n    protected $factories = [\n        MailObserver::class =\n InvokableFactory::class,\n        LogObserver::class =\n InvokableFactory::class,\n    ];\n\n    public function validate($instance)\n    {\n        if (! $plugin instanceof $this-\ninstanceOf) {\n            throw new RuntimeException(sprintf(\n                'Invalid plugin \n%s\n created; not an instance of %s',\n                get_class($instance),\n                $this-\ninstanceOf\n            ));\n        }\n    }\n\n    public function validatePlugin($instance)\n    {\n        $this-\nvalidate($instance);\n    }\n}\n\n\n\n\nThings to note about the above:\n\n\n\n\nIt introduces a new property, \n$instanceOf\n. We'll use this later, when we're\n  ready to clean up post-migration.\n\n\nIt introduces four aliases. This is to allow fetching the various plugins as\n  any of \nmail\n, \nMail\n, \nlog\n, or \nLog\n \n all of which are valid in\n  version 2, but, because version 3 does not normalize names, need to be\n  explicitly aliased.\n\n\nThe aliases point to the fully qualified class name (FQCN) for the service\n  being generated, and these are mapped to \nInvokableFactory\n instances. This\n  means you can also fetch your plugins by their FQCN.\n\n\n\n\nThe above will now work in both version 2 and version 3.\n\n\nAfter you migrate to version 3, you can clean up your plugin manager:\n\n\n\n\nRemove the \nvalidatePlugin()\n method.\n\n\nIf your \nvalidate()\n routine is only checking that the instance is of a single\n  type, and has no other logic, you can remove that implementation as well, as\n  the \nAbstractPluginManager\n already takes care of that when \n$instanceOf\n is\n  defined!\n\n\n\n\nPerforming these steps on the above, we get:\n\n\nuse Zend\\ServiceManager\\AbstractPluginManager;\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nclass ObserverPluginManager extends AbstractPluginManager\n{\n    protected $instanceOf = ObserverInterface::class;\n\n    protected $aliases = [\n        'mail' =\n MailObserver::class,\n        'Mail' =\n MailObserver::class,\n        'log' =\n LogObserver::class,\n        'Log' =\n LogObserver::class,\n    ];\n\n    protected $factories = [\n        MailObserver::class =\n InvokableFactory::class,\n        LogObserver::class =\n InvokableFactory::class,\n    ];\n}\n\n\n\n\nDI Namespace\n\n\nThe \nZend\\ServiceManager\\Di\n namespace has been removed.\n\n\nThe \nZend\\Di\n component is not actively maintained, and has been largely\ndeprecated during the ZF2 lifecycle in favor of the Service Manager. Its usage\nas an abstract factory is problematic and error prone when used in conjunction\nwith the Service Manager; as such, we've removed it for the initial v3 release.\n\n\nWe may re-introduce it via a separate component in the future.\n\n\nMiscellaneous Interfaces, Traits, and Classes\n\n\nThe following interfaces, traits, and classes were \nremoved\n:\n\n\n\n\nZend\\ServiceManager\\MutableCreationOptionsInterface\n; this was previously\n  used by the \nAbstractPluginManager\n, and is no longer required as we ship a\n  separate \nPluginManagerInterface\n, and because the functionality is\n  encompassed by the \nbuild()\n method.\n\n\nZend\\ServiceManager\\MutableCreationOptionsTrait\n\n\nZend\\ServiceManager\\Proxy\\LazyServiceFactoryFactory\n; its capabilities were\n  moved directly into the \nServiceManager\n.\n\n\nZend\\ServiceManager\\ServiceLocatorAwareInterface\n\n\nZend\\ServiceManager\\ServiceLocatorAwareTrait\n\n\nZend\\ServiceManager\\ServiceManagerAwareInterface\n\n\n\n\nThe \nServiceLocatorAware\n and \nServiceManagerAware\n interfaces and traits were\ntoo often abused under v2, and represent the antithesis of the purpose of the\nService Manager component; dependencies should be directly injected, and the\ncontainer should never be composed by objects.\n\n\nThe following classes and interfaces have changes:\n\n\n\n\nZend\\ServiceManager\\Proxy\\LazyServiceFactory\n is now marked \nfinal\n, and\n   implements \nZend\\ServiceManager\\Proxy\\DelegatorFactoryInterface\n. Its\n   dependencies and capabilities remain the same.\n\n\nZend\\ServiceManager\\ConfigInterface\n now is expected to \nreturn\n the modified\n  \nServiceManager\n instance.\n\n\nZend\\ServiceManager\\Config\n was updated to follow the changes to\n  \nConfigInterface\n and \nServiceManager\n, and now returns the updated\n  \nServiceManager\n instance from \nconfigureServiceManager()\n.",
            "title": "Migration Guide"
        },
        {
            "location": "/migration/#migration-guide",
            "text": "The Service Manager was first introduced for Zend Framework 2.0.0. Its API\nremained the same throughout that version.  Version 3 is the first new major release of the Service Manager, and contains a\nnumber of backwards compatibility breaks. These were introduced to provide\nbetter performance and stability.",
            "title": "Migration Guide"
        },
        {
            "location": "/migration/#case-sensitivity-and-normalization",
            "text": "v2 normalized service names as follows:   It stripped non alphanumeric characters.  It lowercased the resulting string.   This was done to help prevent typographical errors from creating configuration\nerrors. However, it also presented a large performance hit, and led to some\nunexpected behaviors.  In v3, service names are case sensitive, and are not normalized in any way.  As such, you  must  refer to services using the same case in which they were\nregistered.",
            "title": "Case Sensitivity and Normalization"
        },
        {
            "location": "/migration/#configuration",
            "text": "A number of changes have been made to configuration of service and plugin\nmanagers:   Minor changes in configuration arrays may impact your usage.  ConfigInterface  implementations and consumers will need updating.",
            "title": "Configuration"
        },
        {
            "location": "/migration/#configuration-arrays",
            "text": "Configuration for v2 consisted of the following:  [\n    'services' =  [\n        // service name =  instance pairs\n    ],\n    'aliases' =  [\n        // alias =  service name pairs\n    ],\n    'invokables' =  [\n        // service name =  class name pairs\n    ],\n    'factories' =  [\n        // service name =  factory pairs\n    ],\n    'abstract_factories' =  [\n        // abstract factories\n    ],\n    'initializers' =  [\n        // initializers\n    ],\n    'delegators' =  [\n        // service name =  [ delegator factories ]\n    ],\n    'shared' =  [\n        // service name =  boolean\n    ],\n    'share_by_default' =  boolean,\n]  In v3, the configuration remains the same, with the following additions:  [\n    'lazy_services' =  [\n        // The class_map is required if using lazy services:\n        'class_map' =  [\n            // service name =  class name pairs\n        ],\n        // The following are optional:\n        'proxies_namespace'  =  'Alternate namespace to use for generated proxy classes',\n        'proxies_target_dir' =  'path in which to write generated proxy classes',\n        'write_proxy_files'  =  true, // boolean; false by default\n    ],\n]  The main change is the addition of integrated lazy service configuration is now\nintegrated.",
            "title": "Configuration arrays"
        },
        {
            "location": "/migration/#configinterface",
            "text": "The principal change to the  ConfigInterface  is the addition of the toArray()  method. This method is intended to return a configuration array in\nthe format listed above, for passing to either the constructor or the configure()  method of the  ServiceManager ..",
            "title": "ConfigInterface"
        },
        {
            "location": "/migration/#config-class",
            "text": "Zend\\ServiceManager\\Config  has been updated to follow the changes to the ConfigInterface  and  ServiceManager . This essentially means that it removes\nthe various getter methods, and adds the  toArray()  method.",
            "title": "Config class"
        },
        {
            "location": "/migration/#invokables",
            "text": "Invokables no longer exist,  at least, not identically to how they existed in\nZF2.  Internally,  ServiceManager  now does the following for  invokables  entries:   If the name and value match, it creates a  factories  entry mapping the\n  service name to  Zend\\ServiceManager\\Factory\\InvokableFactory .  If the name and value  do not  match, it creates an  aliases  entry mapping the\n  service name to the class name,  and  a  factories  entry mapping the class\n  name to  Zend\\ServiceManager\\Factory\\InvokableFactory .   This means that you can use your existing  invokables  configuration from\nversion 2 in version 3. However, we recommend starting to update your\nconfiguration to remove  invokables  entries in favor of factories (and aliases,\nif needed).",
            "title": "Invokables"
        },
        {
            "location": "/migration/#invokables-and-plugin-managers",
            "text": "If you are creating a plugin manager and in-lining invokables into the class\ndefinition, you will need to make some changes.  $invokableClasses  will need to become  $factories  entries, and you will\npotentially need to add  $aliases  entries.  As an example, consider the following, from zend-math v2.x:  class AdapterPluginManager extends AbstractPluginManager\n{\n    protected $invokableClasses = [\n        'bcmath' =  Adapter\\Bcmath::class,\n        'gmp'    =  Adapter\\Gmp::class,\n    ];\n}  Because we no longer define an  $invokableClasses  property, for v3.x, this\nnow becomes:  use Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nclass AdapterPluginManager extends AbstractPluginManager\n{\n    protected $aliases = [\n        'bcmath' =  Adapter\\Bcmath::class,\n        'gmp'    =  Adapter\\Gmp::class,\n    ];\n\n    protected $factories = [\n        Adapter\\BcMath::class =  InvokableFactory::class,\n        Adapter\\Gmp::class    =  InvokableFactory::class,\n    ];\n}",
            "title": "Invokables and plugin managers"
        },
        {
            "location": "/migration/#lazy-services",
            "text": "In v2, if you wanted to create a lazy service, you needed to take the following\nsteps:   Ensure you have a  config  service, with a  lazy_services  key that contained\n  the configuration necessary for the  LazyServiceFactory .  Assign the  LazyServiceFactoryFactory  as a factory for the\n   LazyServiceFactory  Assign the  LazyServiceFactory  as a delegator factory for your service.   As an example:  use Zend\\ServiceManager\\Proxy\\LazyServiceFactoryFactory;\n\n$config = [\n    'lazy_services' =  [\n        'class_map' =  [\n            'MyClass' =  'MyClass',\n        ],\n        'proxies_namespace'  =  'TestAssetProxy',\n        'proxies_target_dir' =  'data/proxies/',\n        'write_proxy_files'  =  true,\n    ],\n];\n\nreturn [\n    'services' =  [\n        'config' =  $config,\n    ],\n    'invokables' =  [\n        'MyClass' =  'MyClass',\n    ],\n    'factories' =  [\n        'LazyServiceFactory' =  LazyServiceFactoryFactory::class,\n    ],\n    'delegators' =  [\n        'MyClass' =  [\n            'LazyServiceFactory',\n        ],\n    ],\n];  This was done in part because lazy services were introduced later in the v2\ncycle, and not fully integrated in order to retain the API.  In order to reduce the number of dependencies and steps necessary to configure\nlazy services, the following changes were made for v3:   Lazy service configuration can now be passed directly to the service manager;\n  it is no longer dependent on a  config  service.  The ServiceManager itself is now responsible for creating the\n   LazyServiceFactory  delegator factory, based on the configuration present.   The above example becomes the following in v3:  use Zend\\ServiceManager\\Factory\\InvokableFactory;\nuse Zend\\ServiceManager\\Proxy\\LazyServiceFactory;\n\nreturn [\n    'factories' =  [\n        'MyClass' =  InvokableFactory::class,\n    ],\n    'delegators' =  [\n        'MyClass' =  [\n            LazyServiceFactory::class,\n        ],\n    ],\n    'lazy_services' =  [\n        'class_map' =  [\n            'MyClass' =  'MyClass',\n        ],\n        'proxies_namespace'  =  'TestAssetProxy',\n        'proxies_target_dir' =  'data/proxies/',\n        'write_proxy_files'  =  true,\n    ],\n];  Additionally, assuming you have configured lazy services initially with the\nproxy namespace, target directory, etc., you can map lazy services using the new\nmethod  mapLazyService($name, $class) :  $container- mapLazyService('MyClass', 'MyClass');\n// or, more simply:\n$container- mapLazyService('MyClass');",
            "title": "Lazy Services"
        },
        {
            "location": "/migration/#servicelocatorinterface-changes",
            "text": "The  ServiceLocatorInterface  now extends the container-interop \ninterface  ContainerInterface , which defines the same  get()  and  has() \nmethods as were previously defined.  Additionally, it adds a new method:  public function build($name, array $options = null)  This method is defined to  always  return a  new  instance of the requested\nservice, and to allow using the provided  $options  when creating the instance.",
            "title": "ServiceLocatorInterface Changes"
        },
        {
            "location": "/migration/#servicemanager-api-changes",
            "text": "Zend\\ServiceManager\\ServiceManager  remains the primary interface with which\ndevelopers will interact. It has the following changes in v3:   It adds a new method,  configure() , which allows configuring all instance\n  generation capabilities (aliases, factories, abstract factories, etc.) at\n  once.  Peering capabilities were removed.  Exceptions are  always  thrown when service instance creation fails or\n  produces an error; you can no longer disable this.  Configuration no longer requires a  Zend\\ServiceManager\\Config  instance.\n   Config  can be used, but is no needed.  It adds a new method,  build() , for creating discrete service instances.",
            "title": "ServiceManager API Changes"
        },
        {
            "location": "/migration/#methods-removed",
            "text": "The following methods are removed  in v3:   setShareByDefault() / shareByDefault() ; this can be passed during\n  instantiation or via  configure() .  setThrowExceptionInCreate() / getThrowExceptionInCreate() ; exceptions are\n   always  thrown when errors are encountered during service instance creation.  setRetrieveFromPeeringManagerFirst() / retrieveFromPeeringManagerFirst() ;\n  peering is no longer supported.",
            "title": "Methods Removed"
        },
        {
            "location": "/migration/#constructor",
            "text": "The constructor now accepts an array of service configuration, not a Zend\\ServiceManager\\Config  instance.",
            "title": "Constructor"
        },
        {
            "location": "/migration/#use-build-for-discrete-instances",
            "text": "The new method  build()  acts as a factory method for configured services, and\nwill  always  return a new instance, never a shared one.  Additionally, it provides factory capabilities; you may pass an additional,\noptional argument,  $options , which should be an array of additional options a\nfactory may use to create a new instance. This is primarily of interest when\ncreating plugin managers (more on plugin managers below), which may pass that\ninformation on in order to create discrete plugin instances with specific state.  As examples:  use Zend\\Validator\\Between;\n\n$between = $container- build(Between::class, [\n    'min'        =  5,\n    'max'        =  10,\n    'inclusive' =  true,\n]);\n\n$alsoBetween = $container- build(Between::class, [\n    'min'       =  0,\n    'max'       =  100,\n    'inclusive' =  false,\n]);  The above two validators would be different instances, with their own\nconfiguration.",
            "title": "Use build() for discrete instances"
        },
        {
            "location": "/migration/#factories",
            "text": "Internally, the  ServiceManager  now only uses the new factory interfaces\ndefined in the  Zend\\ServiceManager\\Factory  namespace. These  replace  the\ninterfaces defined in version 2, and define completely new signatures.  For migration purposes, all original interfaces were retained, and now inherit\nfrom the new interfaces. This provides a migration path; you can add the methods\ndefined in the new interfaces to your existing factories targeting v2, and\nsafely upgrade. (Typically, you will then have the version 2 methods proxy to\nthose defined in version 3.)",
            "title": "Factories"
        },
        {
            "location": "/migration/#interfaces-and-relations-to-version-2",
            "text": "Version 2 Interface  Version 3 Interface      Zend\\ServiceManager\\AbstractFactoryInterface  Zend\\ServiceManager\\Factory\\AbstractFactoryInterface    Zend\\ServiceManager\\DelegatorFactoryInterface  Zend\\ServiceManager\\Factory\\DelegatorFactoryInterface    Zend\\ServiceManager\\FactoryInterface  Zend\\ServiceManager\\Factory\\FactoryInterface     The version 2 interfaces now extend those in version 3, but are marked deprecated . You can continue to use them, but will be required to update\nyour code to use the new interfaces in the future.",
            "title": "Interfaces and relations to version 2"
        },
        {
            "location": "/migration/#abstractfactoryinterface",
            "text": "The previous signature of the  AbstractFactoryInterface  was:  interface AbstractFactoryInterface\n{\n    /**\n     * Determine if we can create a service with name\n     *\n     * @param ServiceLocatorInterface $serviceLocator\n     * @param $name\n     * @param $requestedName\n     * @return bool\n     */\n    public function canCreateServiceWithName(ServiceLocatorInterface $serviceLocator, $name, $requestedName);\n\n    /**\n     * Create service with name\n     *\n     * @param ServiceLocatorInterface $serviceLocator\n     * @param $name\n     * @param $requestedName\n     * @return mixed\n     */\n    public function createServiceWithName(ServiceLocatorInterface $serviceLocator, $name, $requestedName);\n}  The new signature is:  interface AbstractFactoryInterface extends FactoryInterface\n{\n    /**\n     * Does the factory have a way to create an instance for the service?\n     *\n     * @param  ContainerInterface $container\n     * @param  string $requestedName\n     * @return bool\n     */\n    public function canCreate(ContainerInterface $container, $requestedName);\n}  Note that it now  extends  the  FactoryInterface  (detailed below), and thus the\nfactory logic has the same signature.  In v2, the abstract factory defined the method  canCreateServiceWithName() ; in\nv3, this is renamed to  canCreate() , and the method also now receives only two\narguments, the container and the requested service name.  To prepare your version 2 implementation to work upon upgrade to version 3:   Add the methods  canCreate()  and  __invoke()  as defined in version 3.  Modify your existing  canCreateServiceWithName()  method to proxy to\n   canCreate()  Modify your existing  createServiceWithName()  method to proxy to\n   __invoke()   As an example, given the following implementation from version 2:  use Zend\\ServiceManager\\AbstractFactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\n\nclass LenientAbstractFactory implements AbstractFactoryInterface\n{\n    public function canCreateServiceWithName(ServiceLocatorInterface $services, $name, $requestedName)\n    {\n        return class_exists($requestedName);\n    }\n\n    public function createServiceWithName(ServiceLocatorInterface $services, $name, $requestedName)\n    {\n        return new $requestedName();\n    }\n}  To update this for version 3 compatibility, you will add the methods canCreate()  and  __invoke() , move the code from the existing methods into\nthem, and update the existing methods to proxy to the new methods:  use Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\AbstractFactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\n\nclass LenientAbstractFactory implements AbstractFactoryInterface\n{\n    public function canCreate(ContainerInterface $container, $requestedName)\n    {\n        return class_exists($requestedName);\n    }\n\n    public function canCreateServiceWithName(ServiceLocatorInterface $services, $name, $requestedName)\n    {\n        return $this- canCreate($services, $requestedName);\n    }\n\n    public function __invoke(ContainerInterface $container, $requestedName, array $options = null)\n    {\n        return new $requestedName();\n    }\n\n    public function createServiceWithName(ServiceLocatorInterface $services, $name, $requestedName)\n    {\n        return $this($services, $requestedName);\n    }\n}  After you have upgraded to version 3, you can take the following steps to remove\nthe migration artifacts:   Update your class to implement the new interface.  Remove the  canCreateServiceWithName()  and  createServiceWithName()  methods\n  from your implementation.   From our example above, we would update the class to read as follows:  use Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Factory\\AbstractFactoryInterface; //  -- note the change!\n\nclass LenientAbstractFactory implements AbstractFactoryInterface\n{\n    public function canCreate(ContainerInterface $container, $requestedName)\n    {\n        return class_exists($requestedName);\n    }\n\n    public function __invoke(ContainerInterface $container, $requestedName, array $options = null)\n    {\n        return new $requestedName();\n    }\n}",
            "title": "AbstractFactoryInterface"
        },
        {
            "location": "/migration/#delegatorfactoryinterface",
            "text": "The previous signature of the  DelegatorFactoryInterface  was:  interface DelegatorFactoryInterface\n{\n    /**\n     * A factory that creates delegates of a given service\n     *\n     * @param ServiceLocatorInterface $serviceLocator the service locator which requested the service\n     * @param string                  $name           the normalized service name\n     * @param string                  $requestedName  the requested service name\n     * @param callable                $callback       the callback that is responsible for creating the service\n     *\n     * @return mixed\n     */\n    public function createDelegatorWithName(ServiceLocatorInterface $serviceLocator, $name, $requestedName, $callback);\n}  The new signature is:  interface DelegatorFactoryInterface\n{\n    /**\n     * A factory that creates delegates of a given service\n     *\n     * @param  ContainerInterface $container\n     * @param  string             $name\n     * @param  callable           $callback\n     * @param  null|array         $options\n     * @return object\n     */\n    public function __invoke(ContainerInterface $container, $name, callable $callback, array $options = null);\n}  Note that the  $name  and  $requestedName  arguments are now merged into a\nsingle  $name  argument, and that the factory now allows passing additional\noptions to use (typically as passed via  build() ).  To prepare your existing delegator factories for version 3, take the following\nsteps:   Implement the  __invoke()  method in your existing factory, copying the code\n  from your existing  createDelegatorWithName()  method into it.  Modify the  createDelegatorWithName()  method to proxy to the new method.   Consider the following delegator factory that works for version 2:  use Zend\\ServiceManager\\DelegatorFactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\n\nclass ObserverAttachmentDelegator implements DelegatorFactoryInterface\n{\n    public function createDelegatorWithName(ServiceLocatorInterface $serviceLocator, $name, $requestedName, $callback)\n    {\n        $subject = $callback();\n        $subject- attach($serviceLocator- get(Observer::class);\n        return $subject;\n    }\n}  To prepare this for version 3, we'd implement the  __invoke()  signature from\nversion 3, and modify  createDelegatorWithName()  to proxy to it:  use Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\DelegatorFactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\n\nclass ObserverAttachmentDelegator implements DelegatorFactoryInterface\n{\n    public function __invoke(ContainerInterface $container, $requestedName, callable $callback, array $options = null)\n    {\n        $subject = $callback();\n        $subject- attach($container- get(Observer::class);\n        return $subject;\n    }\n\n    public function createDelegatorWithName(ServiceLocatorInterface $serviceLocator, $name, $requestedName, $callback)\n    {\n        return $this($serviceLocator, $requestedName, $callback);\n    }\n}  After you have upgraded to version 3, you can take the following steps to remove\nthe migration artifacts:   Update your class to implement the new interface.  Remove the  createDelegatorWithName()  method from your implementation.   From our example above, we would update the class to read as follows:  use Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Factory\\DelegatorFactoryInterface; //  -- note the change!\n\nclass ObserverAttachmentDelegator implements DelegatorFactoryInterface\n{\n    public function __invoke(ContainerInterface $container, $requestedName, callable $callback, array $options = null)\n    {\n        $subject = $callback();\n        $subject- attach($container- get(Observer::class);\n        return $subject;\n    }\n}",
            "title": "DelegatorFactoryInterface"
        },
        {
            "location": "/migration/#factoryinterface",
            "text": "The previous signature of the  FactoryInterface  was:  interface FactoryInterface\n{\n    /**\n     * Create service\n     *\n     * @param ServiceLocatorInterface $serviceLocator\n     * @return mixed\n     */\n    public function createService(ServiceLocatorInterface $serviceLocator);\n}  The new signature is:  interface FactoryInterface\n{\n    /**\n     * Create an object\n     *\n     * @param  ContainerInterface $container\n     * @param  string             $requestedName\n     * @param  null|array         $options\n     * @return object\n     */\n    public function __invoke(ContainerInterface $container, $requestedName, array $options = null);\n}  Note that the factory now accepts an additional  required  argument, $requestedName ; v2 already passed this argument, but it was not specified in\nthe interface itself. Additionally, a third  optional  argument,  $options ,\nallows you to provide  $options  to the  ServiceManager::build()  method;\nfactories can then take these into account when creating an instance.  Because factories now can expect to receive the service name, they may be\nre-used for multiple services, largely replacing abstract factories in version\n3.  To prepare your existing factories for version 3, take the following steps:   Implement the  __invoke()  method in your existing factory, copying the code\n  from your existing  createService()  method into it.  Modify the  createService()  method to proxy to the new method.   Consider the following factory that works for version 2:  use Zend\\ServiceManager\\FactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\n\nclass FooFactory implements FactoryInterface\n{\n    public function createService(ServiceLocatorInterface $services)\n    {\n        return new Foo($services- get(Bar::class));\n    }\n}  To prepare this for version 3, we'd implement the  __invoke()  signature from\nversion 3, and modify  createService()  to proxy to it:  use Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\FactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\n\nclass FooFactory implements FactoryInterface\n{\n    public function __invoke(ContainerInterface $container, $requestedName, array $options = null)\n    {\n        return new Foo($container- get(Bar::class));\n    }\n\n    public function createService(ServiceLocatorInterface $services)\n    {\n        return $this($services, Foo::class);\n    }\n}  Note that the call to  $this()  adds a new argument; since your factory isn't\nusing the  $requestedName , this can be anything, but must be passed to prevent\na fatal exception due to a missing argument. In this case, we chose to pass the\nname of the class the factory is creating.  After you have upgraded to version 3, you can take the following steps to remove\nthe migration artifacts:   Update your class to implement the new interface.  Remove the  createService()  method from your implementation.   From our example above, we would update the class to read as follows:  use Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Factory\\FactoryInterface; //  -- note the change!\n\nclass FooFactory implements FactoryInterface\n{\n    public function __invoke(ContainerInterface $container, $requestedName, array $options = null)\n    {\n        return new Foo($container- get(Bar::class));\n    }\n}",
            "title": "FactoryInterface"
        },
        {
            "location": "/migration/#many-factories-already-work-with-v3",
            "text": "Within the skeleton application, tutorial, and even in commonly shipped\nmodules such as those in Apigility, we have typically suggested building your\nfactories as invokable classes. If you were doing this already, your factories\nwill already work with version 3!",
            "title": "Many factories already work with v3!"
        },
        {
            "location": "/migration/#version-2-factories-can-accept-the-requested-name-already",
            "text": "Since 2.2, factories have been passed two additional parameters, the\n\"canonical\" name (a mis-nomer, as it is actually the normalized name), and the\n\"requested\" name (the actual string passed to  get() ). As such, you can\nalready write factories that accept the requested name, and have them\nchange behavior based on that information!",
            "title": "Version 2 factories can accept the requested name already"
        },
        {
            "location": "/migration/#new-invokablefactory-class",
            "text": "Zend\\ServiceManager\\Factory\\InvokableFactory  is a new  FactoryInterface \nimplementation that provides the capabilities of the \"invokable classes\" present\nin version 2. It essentially instantiates and returns the requested class name;\nif  $options  is non-empty, it passes them directly to the constructor.  This class was  added to the version 2 tree \nto allow developers to start using it when preparing their code for version 3.\nThis is particularly of interest when creating plugin managers, as you'll\ntypically want the internal configuration to only include factories and aliases.",
            "title": "New InvokableFactory Class"
        },
        {
            "location": "/migration/#initializers",
            "text": "Initializers are still present in the Service Manager component, but exist\nprimarily for backwards compatibility; we recommend using delegator factories\nfor setter and interface injection instead of initializers, as those will be run\nper-service, versus for all services.  For migration purposes, the original interface was retained, and now inherits\nfrom the new interface. This provides a migration path; you can add the method\ndefined in the new interface to your existing initializers targeting v2, and\nsafely upgrade. (Typically, you will then have the version 2 method proxy to\nthe one defined in version 3.)  The following changes were made to initializers:   Zend\\ServiceManager\\InitializerInterface  was renamed to\n   Zend\\ServiceManager\\Initializer\\InitializerInterface .  The interface itself has a new signature.   The previous signature was:  public function initialize($instance, ServiceLocatorInterface $serviceLocator)  It is now:  public function __invoke(ContainerInterface $container, $instance)  The changes were made to ensure the signature is internally consistent with the\nvarious factories.  To prepare your existing initializers for version 3, take the following steps:   Implement the  __invoke()  method in your existing factory, copying the code\n  from your existing  initialize()  method into it.  Modify the  initialize()  method to proxy to the new method.   As an example, consider this initializer for version 2:  use Zend\\ServiceManager\\InitializerInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\n\nclass FooInitializer implements InitializerInterface\n{\n    public function initializer($instance, ServiceLocatorInterface $services)\n    {\n        if (! $instance implements FooAwareInterface) {\n            return $instance;\n        }\n        $instance- setFoo($services- get(FooInterface::class);\n        return $instance;\n    }\n}  To prepare this for version 3, we'd implement the  __invoke()  signature from\nversion 3, and modify  initialize()  to proxy to it:  use Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\InitializerInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\n\nclass FooInitializer implements InitializerInterface\n{\n    public function __invoke(ContainerInterface $container, $instance)\n    {\n        if (! $instance implements FooAwareInterface) {\n            return $instance;\n        }\n        $container- setFoo($services- get(FooInterface::class);\n        return $instance;\n    }\n\n    public function initializer($instance, ServiceLocatorInterface $services)\n    {\n        return $this($services, $instance);\n    }\n}  After you have upgraded to version 3, you can take the following steps to remove\nthe migration artifacts:   Update your class to implement the new interface.  Remove the  initialize()  method from your implementation.   From our example above, we would update the class to read as follows:  use Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Initializer\\InitializerInterface; //  -- note the change!\n\nclass FooInitializer implements InitializerInterface\n{\n    public function __invoke(ContainerInterface $container, $instance)\n    {\n        if (! $instance implements FooAwareInterface) {\n            return $instance;\n        }\n        $container- setFoo($services- get(FooInterface::class);\n        return $instance;\n    }\n}",
            "title": "Initializers"
        },
        {
            "location": "/migration/#update-your-callables",
            "text": "Version 2 allows you to provide initializers as PHP callables. However, this\nmeans that the signature of those callables is incorrect for version 3!  To make your code forwards compatible, you have two paths:  The first is to simply provide an  InitializerInterface  implementation\ninstead. This guarantees that the correct method is called based on the\nversion of the  ServiceManager  in use.  The second approach is to omit typehints on the arguments, and do typechecks\ninternally. As an example, let's say you have the following:  $container- addInitializer(function ($instance, ContainerInterface $container) {\n     if (! $instance implements FooAwareInterface) {\n         return $instance;\n     }\n     $container- setFoo($services- get(FooInterface::class);\n     return $instance;\n});  To make this future-proof, remove the typehints, and check the types within\nthe callable:  $container- addInitializer(function ($first, $second) {\n     if ($first instanceof ContainerInterface) {\n         $container = $first;\n         $instance = $second;\n     } else {\n         $container = $second;\n         $instance = $first;\n     }\n     if (! $instance implements FooAwareInterface) {\n         return $instance;\n     }\n     $container- setFoo($services- get(FooInterface::class);\n     return $instance;\n});  This approach can also be done if you omitted typehints in the first place.\nRegardless, the important part to remember is that order of arguments is\ninverted between the two versions.",
            "title": "Update your callables!"
        },
        {
            "location": "/migration/#plugin-managers",
            "text": "In version 2, plugin managers were  ServiceManager  instances that implemented\nboth the  MutableCreationOptionsInterface  and  ServiceLocatorAwareInterface ,\nand extended  AbstractPluginManager .  Plugin managers passed themselves to\nfactories, abstract factories, etc., requiring pulling the parent service\nmanager, if composed, in order to resolve application-level dependencies.  In version 3, we define the following:   Zend\\ServiceManager\\PluginManagerInterface , which provides the public API\n  differences from the  ServiceLocatorInterface .  Zend\\ServiceManager\\AbstractPluginManager , which gives the basic\n  capabilities for plugin managers. The class now has a (semi)  required \n  dependency on the application-level service manager instance, which is passed\n  to all factories, abstract factories, etc. (More on this below.)",
            "title": "Plugin Managers"
        },
        {
            "location": "/migration/#pluginmanagerinterface",
            "text": "Zend\\ServiceManager\\PluginInterface  is a new interface for version 3,\nextending  ServiceLocatorInterface  and adding one method:  /**\n * Validate an instance\n *\n * @param  object $instance\n * @return void\n * @throws InvalidServiceException If created instance does not respect the\n *     constraint on type imposed by the plugin manager\n */\npublic function validate($instance);  All plugin managers  must  implement this interface. For backwards-compatibility\npurposes,  AbstractPluginManager  will check for the  validatePlugin()  method\n(defined as abstract in v2), and, on discovery, trigger an  E_USER_DEPRECATED \nnotice, followed by invocation of that method.",
            "title": "PluginManagerInterface"
        },
        {
            "location": "/migration/#abstractpluginmanager",
            "text": "As it did in version 2,  AbstractPluginManager  extends  ServiceManager .  That\nmeans that all changes made to the  ServiceManager  for v3 also apply to the AbstractPluginManager .  In addition, review the following changes.",
            "title": "AbstractPluginManager"
        },
        {
            "location": "/migration/#constructor_1",
            "text": "The constructor now accepts the following arguments, in the following order:  The parent container instance; this is usually the application-level\n     ServiceManager  instance.  Optionally, an array of configuration for the plugin manager instance; this\n    should have the same format as for a  ServiceManager  instance.  validatePlugin()  was renamed to  validate()  (now defined in\n   PluginManagerInterface ). The  AbstractPluginManager  provides\n  a basic implementation (detailed below).  The signature of  get()  changes (more below).   For backwards compatibility purposes, the constructor  also  allows the\nfollowing for the initial argument:   A  null  value. In this case, the plugin manager will use itself as the\n  creation context,  but also raise a deprecation notice indicating a\n  container should be passed instead.  You can pass the parent container\n  to the  setServiceLocator()  method to reset the creation context, but,\n  again, this raises a deprecation notice.  A  ConfigInterface  instance. In this case, the plugin manager will call\n  the config instance's  toArray()  method to cast it to an array, and use the\n  return value as the configuration to pass to the parent constructor. As with\n  the  null  value, the plugin manager will be set as its own creation context.",
            "title": "Constructor"
        },
        {
            "location": "/migration/#validation",
            "text": "The  validate()  method is defined as follows:  public function validate($instance)\n{\n    if (method_exists($this, 'validatePlugin')) {\n        trigger_error(sprintf(\n            '%s::validatePlugin() has been deprecated as of 3.0; please define validate() instead',\n            get_class($this)\n        ), E_USER_DEPRECATED);\n        $this- validatePlugin($instance);\n        return;\n    }\n\n    if (empty($this- instanceOf) || $instance instanceof $this- instanceOf) {\n        return;\n    }\n\n    throw new InvalidServiceException(sprintf(\n        'Plugin manager  %s  expected an instance of type  %s , but  %s  was received',\n        __CLASS__,\n        $this- instanceOf,\n        is_object($instance) ? get_class($instance) : gettype($instance)\n    ));\n}  The two takeaways from this are:   If you are upgrading from v2, your code should continue to work,  but will\n  emit a deprecation notice . The way to remove the deprecation notice is to\n  rename the  validatePlugin()  method to  validate() , or to remove it and\n  define the  $instanceOf  property (if all you're doing is checking the\n  plugin against a single typehint).  Most plugin manager instances can simply define the  $instanceOf  property to\n  indicate what plugin interface is considered valid for the plugin manager, and\n  make no further changes to the abstract plugin manager:   protected $instanceOf = ValidatorInterface::class;",
            "title": "Validation"
        },
        {
            "location": "/migration/#get",
            "text": "The  get()  signature changes from:  public function get($name, $options = [], $usePeeringServiceManagers = true)  to:  public function get($name, array $options = null)  Essentially:  $options  now  must  be an array if passed, and peering is no\nlonger supported.",
            "title": "get()"
        },
        {
            "location": "/migration/#deprecated-methods",
            "text": "Finally, the following methods from v2's  ServiceLocatorAwareInterface  are\nretained (without implementing the interface), but marked as deprecated:   setServiceLocator() . This method exists as many tests and plugin manager\n  factories were using it to inject the parent locator (now called the creation\n  context). This method may still be used, and will now set the creation context\n  for the plugin manager, but also emit a deprecation warning.  getServiceLocator()  is implemented in  ServiceManager  (from which\n   AbstractPluginManager  inherits), but marked as deprecated.   Regarding this latter point,  getServiceLocator()  exists to provide backwards\ncompatibility  for existing plugin factories . These factories typically pull\ndependencies from the parent/application container in order to initialize the\nplugin. In v2, this would look like:  function ($plugins)\n{\n    $services = $plugins- getServiceLocator();\n\n    // pull dependencies from $services:\n    $foo = $services- get('Foo');\n    $bar = $services- get('Bar');\n\n    return new Plugin($foo, $bar);\n}  In v3, the initial argument to the factory is not the plugin manager instance,\nbut the  creation context , which is analogous to the parent locator in v2. In\norder to preserve existing behavior, we added the  getServiceLocator()  method\nto the  ServiceManager . As such, the above will continue to work in v3.  However, this method is marked as deprecated, and will emit an E_USER_DEPRECATED  notice. To remove the notice, you will need to upgrade your\ncode. The above example thus becomes:  function ($services)\n{\n    // pull dependencies from $services:\n    $foo = $services- get('Foo');\n    $bar = $services- get('Bar');\n\n    return new Plugin($foo, $bar);\n}  If you  were  using the passed plugin manager and pulling other plugins, you\nwill need to update your code to retrieve the plugin manager from the passed\ncontainer. As an example, given this:  function ($plugins)\n{\n    $anotherPlugin = $plugins- get('AnotherPlugin');\n    return new Plugin($anotherPlugin);\n}  You will need to rewrite it to:  function ($services)\n{\n    $plugins = $services- get('PluginManager');\n    $anotherPlugin = $plugins- get('AnotherPlugin');\n    return new Plugin($anotherPlugin);\n}",
            "title": "Deprecated methods"
        },
        {
            "location": "/migration/#plugin-service-creation",
            "text": "The  get()  method has new behavior:   When non-empty  $options  are passed, it  always  delegates to  build() , and\n  thus will  always  return a  new instance . If you are using  $options , the\n  assumption is that you are using the plugin manager as a factory, and thus the\n  instance should not be cached.  Without  $options ,  get()  will cache by default (the default behavior of\n   ServiceManager ). To  never  cache instances, either set the\n   $sharedByDefault  class property to  false , or pass a boolean  false  value\n  via the  shared_by_default  configuration key.",
            "title": "Plugin Service Creation"
        },
        {
            "location": "/migration/#migration-example",
            "text": "Let's consider the following plugin manager geared towards version 2:  use RuntimeException;\nuse Zend\\ServiceManager\\AbstractPluginManager;\n\nclass ObserverPluginManager extends AbstractPluginManager\n{\n    protected $invokables = [\n        'mail' =  MailObserver::class,\n        'log' =  LogObserver::class,\n    ];\n\n    public function validatePlugin($instance)\n    {\n        if (! $plugin instanceof ObserverInterface) {\n            throw new RuntimeException(sprintf(\n                'Invalid plugin  %s  created; not an instance of %s',\n                get_class($instance),\n                ObserverInterface::class\n            ));\n        }\n    }\n}  To prepare this for version 3, we need to do the following:   We need to change the  $invokables  configuration to a combination of\n   factories  and  aliases .  We need to implement a  validate()  method.  We need to update the  validatePlugin()  method to proxy to  validate() .   Doing so, we get the following result:  use RuntimeException;\nuse Zend\\ServiceManager\\AbstractPluginManager;\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nclass ObserverPluginManager extends AbstractPluginManager\n{\n    protected $instanceOf = ObserverInterface::class;\n\n    protected $aliases = [\n        'mail' =  MailObserver::class,\n        'Mail' =  MailObserver::class,\n        'log' =  LogObserver::class,\n        'Log' =  LogObserver::class,\n    ];\n\n    protected $factories = [\n        MailObserver::class =  InvokableFactory::class,\n        LogObserver::class =  InvokableFactory::class,\n    ];\n\n    public function validate($instance)\n    {\n        if (! $plugin instanceof $this- instanceOf) {\n            throw new RuntimeException(sprintf(\n                'Invalid plugin  %s  created; not an instance of %s',\n                get_class($instance),\n                $this- instanceOf\n            ));\n        }\n    }\n\n    public function validatePlugin($instance)\n    {\n        $this- validate($instance);\n    }\n}  Things to note about the above:   It introduces a new property,  $instanceOf . We'll use this later, when we're\n  ready to clean up post-migration.  It introduces four aliases. This is to allow fetching the various plugins as\n  any of  mail ,  Mail ,  log , or  Log    all of which are valid in\n  version 2, but, because version 3 does not normalize names, need to be\n  explicitly aliased.  The aliases point to the fully qualified class name (FQCN) for the service\n  being generated, and these are mapped to  InvokableFactory  instances. This\n  means you can also fetch your plugins by their FQCN.   The above will now work in both version 2 and version 3.  After you migrate to version 3, you can clean up your plugin manager:   Remove the  validatePlugin()  method.  If your  validate()  routine is only checking that the instance is of a single\n  type, and has no other logic, you can remove that implementation as well, as\n  the  AbstractPluginManager  already takes care of that when  $instanceOf  is\n  defined!   Performing these steps on the above, we get:  use Zend\\ServiceManager\\AbstractPluginManager;\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nclass ObserverPluginManager extends AbstractPluginManager\n{\n    protected $instanceOf = ObserverInterface::class;\n\n    protected $aliases = [\n        'mail' =  MailObserver::class,\n        'Mail' =  MailObserver::class,\n        'log' =  LogObserver::class,\n        'Log' =  LogObserver::class,\n    ];\n\n    protected $factories = [\n        MailObserver::class =  InvokableFactory::class,\n        LogObserver::class =  InvokableFactory::class,\n    ];\n}",
            "title": "Migration example"
        },
        {
            "location": "/migration/#di-namespace",
            "text": "The  Zend\\ServiceManager\\Di  namespace has been removed.  The  Zend\\Di  component is not actively maintained, and has been largely\ndeprecated during the ZF2 lifecycle in favor of the Service Manager. Its usage\nas an abstract factory is problematic and error prone when used in conjunction\nwith the Service Manager; as such, we've removed it for the initial v3 release.  We may re-introduce it via a separate component in the future.",
            "title": "DI Namespace"
        },
        {
            "location": "/migration/#miscellaneous-interfaces-traits-and-classes",
            "text": "The following interfaces, traits, and classes were  removed :   Zend\\ServiceManager\\MutableCreationOptionsInterface ; this was previously\n  used by the  AbstractPluginManager , and is no longer required as we ship a\n  separate  PluginManagerInterface , and because the functionality is\n  encompassed by the  build()  method.  Zend\\ServiceManager\\MutableCreationOptionsTrait  Zend\\ServiceManager\\Proxy\\LazyServiceFactoryFactory ; its capabilities were\n  moved directly into the  ServiceManager .  Zend\\ServiceManager\\ServiceLocatorAwareInterface  Zend\\ServiceManager\\ServiceLocatorAwareTrait  Zend\\ServiceManager\\ServiceManagerAwareInterface   The  ServiceLocatorAware  and  ServiceManagerAware  interfaces and traits were\ntoo often abused under v2, and represent the antithesis of the purpose of the\nService Manager component; dependencies should be directly injected, and the\ncontainer should never be composed by objects.  The following classes and interfaces have changes:   Zend\\ServiceManager\\Proxy\\LazyServiceFactory  is now marked  final , and\n   implements  Zend\\ServiceManager\\Proxy\\DelegatorFactoryInterface . Its\n   dependencies and capabilities remain the same.  Zend\\ServiceManager\\ConfigInterface  now is expected to  return  the modified\n   ServiceManager  instance.  Zend\\ServiceManager\\Config  was updated to follow the changes to\n   ConfigInterface  and  ServiceManager , and now returns the updated\n   ServiceManager  instance from  configureServiceManager() .",
            "title": "Miscellaneous Interfaces, Traits, and Classes"
        }
    ]
}